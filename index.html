<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>FCS AI Generator Suite</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  :root { --bg:#f7f9fc; --fg:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --accent:#0b5cff;
          --en:#1a73e8; --es:#d93025; --head:#0f172a; }
  body { background: var(--bg); color: var(--fg); font-family: Calibri, Arial, sans-serif; font-size: 15px; margin:0; }
  .fcs-wrap { max-width: 980px; margin: 28px auto; padding: 0 16px; }
  h1 { font-size: 28px; font-weight:700; text-align:center; margin-bottom: 28px; color: var(--head); }
  h2 { font-size: 20px; font-weight:700; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; color: var(--head); }
  .fcs-card { border:1px solid var(--border); border-radius: 12px; padding: 24px; background:var(--panel); margin-bottom: 20px; }
  label { font-weight: 600; font-size: 14px; display: block; margin-bottom: 6px; }
  input[type="text"], select, input[type="number"], textarea { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; font-size:15px; box-sizing:border-box; }
  input:disabled { background-color: #f8f9fa; }
  .hint, .small { font-size: 12px; color: var(--muted); margin-top: 4px; }
  button { padding: 10px 16px; border-radius: 8px; border:1px solid var(--border); background:#f6f8fb; cursor: pointer; font-weight: 600; font-size:15px; transition: all 0.2s; }
  button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
  button:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.08); }
  button:disabled { cursor: not-allowed; opacity: 0.6; }
  .fcs-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
  .fcs-tab-btn { flex-grow: 1; text-align: center; }
  .fcs-generator { display: block; }
  .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 16px; align-items: end; }
  .six { grid-column: span 6; } .twelve { grid-column: span 12; }
  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; } .grid-full { grid-column: 1 / -1; }
  .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top:20px; align-items:center; }
  .status { margin-top:10px; min-height:1.5em; text-align:left; color:var(--muted); font-size:13px; }
  .output-container { border:1px solid var(--border); border-radius:12px; padding:24px; background:#fff; min-height: 240px; margin-top:12px; }
  .output-container h1, .output-container h2 { text-align: center; color: #0f172a !important; }
  .output-container table { width:100%; border-collapse: separate; border-spacing: 0; margin-top: 12px; font-size:10pt; }
  .output-container th, .output-container td { border:1px solid #e5e7eb; padding:8px; vertical-align:top; }
  .output-container th { background: #f5f7fb; }
  .output-container tr:nth-child(even) td { background: #fafafa; }
  .output-container .en { color: var(--en); font-weight: bold; }
  .output-container .es { color: var(--es); font-weight: bold; }
  .output-container .full-black { color: var(--fg); font-weight: 700; }

  .tts-line-btn { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; margin-right:6px; border:1px solid #dbe2ef;
    border-radius:999px; background:#eef2ff; cursor:pointer; font-size:12px; line-height:1; }
  .tts-line-btn[data-tts="es"] { background:#fdeaea; border-color:#f5c2c7; }
  .tts-line-btn:hover { filter:brightness(0.98); }

  .conv-ctrls { display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
  .conv-ctrls button { padding:6px 10px; font-size:12px; }

  @media (max-width: 860px){ .six, .twelve { grid-column: span 12; } .grid-2 { grid-template-columns:1fr; } }
</style>
</head>
<body>
<div class="fcs-wrap">
  <h1>FCS AI GENERATOR SUITE</h1>
  <div class="fcs-tabs">
    <button id="tab-vocab" class="fcs-tab-btn primary">Vocabulary</button>
  </div>

  <div id="gen-vocab" class="fcs-generator"></div>
</div>

<script>
"use strict";
(function(){
  const $ = id => document.getElementById(id);
  const API_URL = "/api/index";

  /* ---------- Helpers ---------- */
  function decodeIfEscaped(html) {
    const s = String(html || '');
    if(/&lt;(!DOCTYPE|html|head|body|div|table|h1|h2)/i.test(s)) {
      const ta = document.createElement('textarea');
      ta.innerHTML = s;
      return ta.value;
    }
    return s;
  }
  function extractDocHTML(html) {
    const parsed = new DOMParser().parseFromString(html, 'text/html');
    let node = parsed.querySelector('.fcs-doc') || parsed.body || parsed.documentElement;
    node.querySelectorAll('script').forEach(s => s.remove());
    return node.innerHTML || '';
  }
  function renderGenerated(html, container) {
    const normalized = decodeIfEscaped(html);
    const safeInner = extractDocHTML(normalized);
    container.innerHTML = safeInner || normalized;
  }
  const safeForScriptTemplate = s => String(s || '').replace(/<\/script/gi,'<\\/script');

  // Lightweight TTS (per-line)
  const Speech = (function() {
    let voices = [], ready = false;
    function load() { voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : []; return voices.length > 0; }
    async function ensure() {
      if (!('speechSynthesis' in window)) return [];
      if (ready && voices.length) return voices;
      if (load()) { ready = true; return voices; }
      return new Promise(res => {
        const h = () => { if (load()) { ready = true; window.speechSynthesis.onvoiceschanged = null; res(voices); } };
        window.speechSynthesis.onvoiceschanged = h; setTimeout(h, 800);
      });
    }
    function pick(lang) {
      const L = String(lang || '').toLowerCase();
      return voices.find(v => v.lang.toLowerCase() === L)
          || voices.find(v => v.lang.toLowerCase().startsWith(L.split('-')[0])) || null;
    }
    function speak(text, lang) {
      if (!('speechSynthesis' in window)) return;
      const t = (text || '').replace(/\s+/g, ' ').trim(); if (!t) return;
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(t);
      u.lang = (lang === 'es' ? 'es-ES' : 'en-US');
      const v = pick(u.lang); if (v) u.voice = v;
      window.speechSynthesis.speak(u);
    }
    return { ensure, speak, pick };
  })();

  function cleanCellText(cell) {
    return (cell.innerText || '').replace(/^\s*üîä\s*(EN|ES)\s*/, '').trim();
  }

  function addPerLineTTS(root) {
    if (!root || !('speechSynthesis' in window)) return;
    root.querySelectorAll('table tbody tr').forEach(tr => {
      const tds = tr.querySelectorAll('td');
      if (tds.length < 2) return;
      ['en','es'].forEach((lang, idx) => {
        const cell = tds[idx];
        if (!cell || cell.querySelector('.tts-line-btn')) return;
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'tts-line-btn'; btn.dataset.tts = lang;
        btn.textContent = 'üîä ' + (lang === 'en' ? 'EN' : 'ES');
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const text = cleanCellText(cell);
          Speech.speak(text, lang);
        });
        cell.insertBefore(btn, cell.firstChild);
      });
    });
  }

  // Overall conversation controls (not used for Vocabulary output, safe no-op)
  function addConversationGlobalTTS(root) {
    if (!root || !('speechSynthesis' in window)) return;
    const sections = Array.from(root.querySelectorAll('.section')).filter(sec => {
      const h2 = sec.querySelector('h2');
      return h2 && /^Conversation\s+\d+/i.test(h2.textContent.trim());
    });
    sections.forEach(sec => {
      if (sec.querySelector('.conv-ctrls')) return;
      const ctrl = document.createElement('div');
      ctrl.className = 'conv-ctrls';
      ctrl.innerHTML = `<button type="button" data-act="play">‚ñ∂ Play All</button>
                        <button type="button" data-act="pause">‚è∏ Pause</button>
                        <button type="button" data-act="stop">‚èπ Stop</button>`;
      sec.insertBefore(ctrl, sec.querySelector('table'));

      let queue = [], idx = 0, playing = false;
      function buildQueue() {
        queue = [];
        const rows = sec.querySelectorAll('tbody tr');
        rows.forEach(tr => {
          const tds = tr.querySelectorAll('td');
          if (tds.length < 2) return;
          const en = cleanCellText(tds[0]);
          const es = cleanCellText(tds[1]);
          if (en) queue.push({ text: en, lang: 'en-US' });
          if (es) queue.push({ text: es, lang: 'es-ES' });
        });
      }
      function speakNext() {
        if (!playing) return;
        if (idx >= queue.length) { playing = false; return; }
        const { text, lang } = queue[idx++];
        const u = new SpeechSynthesisUtterance(text);
        u.lang = lang;
        const v = Speech.pick(lang);
        if (v) u.voice = v;
        u.onend = () => speakNext();
        window.speechSynthesis.speak(u);
      }

      ctrl.querySelector('[data-act="play"]').addEventListener('click', async () => {
        await Speech.ensure();
        window.speechSynthesis.cancel();
        buildQueue(); idx = 0; playing = true;
        speakNext();
      });
      ctrl.querySelector('[data-act="pause"]').addEventListener('click', () => {
        if (window.speechSynthesis.paused) { window.speechSynthesis.resume(); }
        else { window.speechSynthesis.pause(); }
      });
      ctrl.querySelector('[data-act="stop"]').addEventListener('click', () => {
        playing = false; window.speechSynthesis.cancel();
      });
    });
  }

  async function callAPI(prompt) {
    const resp = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt })
    });
    const json = await resp.json();
    if (!resp.ok) throw new Error(json.details || json.error || "Unknown server error.");
    return json.content;
  }

  async function generateAndRender(basePrompt, button, statusEl, outputEl, validator, maxRetries = 0) {
    try {
      button.disabled = true;
      statusEl.textContent = "Generating...";
      outputEl.innerHTML = "<h4>Please wait. AI is working...</h4>";
      let html = await callAPI(basePrompt);
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        const err = validator ? validator(html) : "";
        if (!err) break;
        statusEl.textContent = `Fixing constraints‚Ä¶ (${attempt + 1}/${maxRetries})`;
        html = await callAPI(basePrompt + `\n\n<!-- FIX STRICTLY:\n${err}\nABSOLUTE COMPLIANCE: Meet the numeric ranges exactly without reducing requested counts.\n-->`);
      }
      renderGenerated(html, outputEl);
      await Speech.ensure();
      addPerLineTTS(outputEl);
      addConversationGlobalTTS(outputEl);
      statusEl.textContent = "Done.";
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Generation failed.";
      outputEl.innerHTML = "<p style='color:#d93025'>An error occurred while generating. Please try again.</p>";
    } finally {
      button.disabled = false;
    }
  }

  function downloadAsExcel(container, statusEl, filename) {
    try {
      const firstTable = container.querySelector("table");
      if (!firstTable) { statusEl.textContent = "No data to export."; return; }
      statusEl.textContent = "Creating Excel...";
      const wb = XLSX.utils.book_new(), rows = [];
      const title = container.querySelector("h1") ? container.querySelector("h1").innerText : (filename || 'Export');
      rows.push([title]); rows.push([]);
      container.querySelectorAll("h2, table").forEach(el => {
        if (el.tagName === "H2") { rows.push([el.innerText]); }
        if (el.tagName === "TABLE") {
          el.querySelectorAll("tr").forEach(tr => {
            const line = Array.from(tr.querySelectorAll("th, td")).map(td => {
              const clone = td.cloneNode(true);
              clone.querySelectorAll('.tts-line-btn').forEach(b => b.remove());
              return clone.innerText;
            });
            rows.push(line);
          });
          rows.push([]);
        }
      });
      const ws = XLSX.utils.aoa_to_sheet(rows);
      ws["!cols"] = rows.reduce((acc, row) => {
        row.forEach((cell, i) => {
          const w = (cell ? cell.toString() : "").length + 2;
          if (!acc[i] || acc[i].wch < w) acc[i] = { wch: w };
        });
        return acc;
      }, []);
      XLSX.utils.book_append_sheet(wb, ws, "Generated Content");
      XLSX.writeFile(wb, `${(filename || 'Export').replace(/\s+/g, "_")}.xlsx`);
      statusEl.textContent = "Download started.";
    } catch (e) {
      console.error("Excel Error:", e);
      statusEl.textContent = "Failed to create Excel.";
    }
  }

  function copyToClipboard(container, statusEl) {
    try {
      const txt = container.innerText.trim();
      if (!txt) { statusEl.textContent = "Nothing to copy."; return; }
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(txt).then(() => statusEl.textContent = "Copied!", () => {
          const t = document.createElement("textarea");
          t.value = txt; document.body.appendChild(t); t.select();
          try {
            if (document.execCommand("copy")) statusEl.textContent = "Copied!";
            else statusEl.textContent = "Copy failed.";
          } catch (e) { statusEl.textContent = "Copy failed."; }
          document.body.removeChild(t);
        });
      } else {
        const t = document.createElement("textarea");
        t.value = txt; document.body.appendChild(t); t.select();
        try {
          if (document.execCommand("copy")) statusEl.textContent = "Copied!";
          else statusEl.textContent = "Copy failed.";
        } catch (e) {
          statusEl.textContent = "Copy failed.";
        }
        document.body.removeChild(t);
      }
    } catch (e) {
      statusEl.textContent = "Copy failed.";
    }
  }
  function copyText(text, statusEl) {
    const t = (text || "").trim();
    if (!t) { statusEl.textContent = "Nothing to copy."; return; }
    if (navigator.clipboard && window.isSecureContext) {
      navigator.clipboard.writeText(t).then(() => statusEl.textContent = "Prompt copied!", () => {
        const ta = document.createElement("textarea");
        ta.value = t; document.body.appendChild(ta); ta.select();
        try {
          if (document.execCommand("copy")) statusEl.textContent = "Prompt copied!";
          else statusEl.textContent = "Copy failed.";
        } catch (e) { statusEl.textContent = "Copy failed."; }
        document.body.removeChild(ta);
      });
    } else {
      const ta = document.createElement("textarea");
      ta.value = t; document.body.appendChild(ta); ta.select();
      try {
        if (document.execCommand("copy")) statusEl.textContent = "Prompt copied!";
        else statusEl.textContent = "Copy failed.";
      } catch (e) {
        statusEl.textContent = "Copy failed.";
      }
      document.body.removeChild(ta);
    }
  }

  function copyContent(mode, container, statusEl) {
    try {
      let text = "";
      if (mode === 'es-only') {
        if (container.id === 'v-output') {
          const esWords = [];
          // Collect spans from specific section titles rather than relying on index order
          const wanted = ["Nouns","Verbs in Sentences","Adjectives","Adverbs"];
          container.querySelectorAll('.section').forEach(sec => {
            const h2 = sec.querySelector('h2');
            const title = h2 ? h2.textContent.trim() : '';
            if (wanted.includes(title)) {
              sec.querySelectorAll('.es').forEach(span => {
                const word = span.innerText.trim();
                if (word) esWords.push(word);
              });
            }
          });
          text = esWords.join("\n");
        } else {
          text = container.innerText.trim(); // fallback
        }
      } else {
        text = container.innerText.trim();
      }
      if (!text) { statusEl.textContent = "Nothing to copy."; return; }
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
        }, () => {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try {
            if (document.execCommand("copy")) {
              statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
            } else {
              statusEl.textContent = "Copy failed.";
            }
          } catch (e) {
            statusEl.textContent = "Copy failed.";
          }
          document.body.removeChild(ta);
        });
      } else {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        try {
          if (document.execCommand("copy")) {
            statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
          } else {
            statusEl.textContent = "Copy failed.";
          }
        } catch (e) {
          statusEl.textContent = "Copy failed.";
        }
        document.body.removeChild(ta);
      }
    } catch (err) {
      statusEl.textContent = "Copy failed.";
    }
  }

  /* ===== Shared sentence splitter ===== */
  function splitIntoSentences(text) {
    const norm = String(text || '').replace(/\s+/g, ' ').trim();
    if (!norm) return [];
    const parts = norm.match(/[^.!?]+[.!?]?/g) || [];
    return parts.map(s => s.trim()).filter(Boolean);
  }

  /* =========================
     Vocabulary Generator
     ========================= */
  (function setupVocab() {
    const vocabUI = 
      `<div class="fcs-card">
        <h2>Vocabulary Creator</h2>
        <div class="grid">
          <div class="six"><label for="v-topic">Topic</label><input id="v-topic" type="text" placeholder="e.g., At the Airport"></div>
          <div class="six"><label for="v-plan">Word Count Plan</label>
            <select id="v-plan">
              <option value="1" selected>Word Count 1</option>
              <option value="2">Word Count 2</option>
              <option value="3">Word Count 3</option>
              <option value="4">Word Count 4</option>
              <option value="5">Word Count 5</option>
              <option value="custom">Custom</option>
            </select>
            <div id="v-presetText" class="hint"></div>
          </div>
          <div class="twelve">
            <label>Sections to Include (multi-select)</label>
            <div id="v-sections" style="display:flex; flex-wrap:wrap; gap:14px;">
              <label><input type="checkbox" id="v-sec-all" checked> All</label>
              <label><input type="checkbox" class="v-sec" value="nouns" checked> Nouns</label>
              <label><input type="checkbox" class="v-sec" value="verbs" checked> Verbs</label>
              <label><input type="checkbox" class="v-sec" value="adjectives" checked> Adjectives</label>
              <label><input type="checkbox" class="v-sec" value="adverbs" checked> Adverbs</label>
              <label><input type="checkbox" class="v-sec" value="phrases" checked> Common Phrases</label>
              <label><input type="checkbox" class="v-sec" value="questions" checked> Common Questions</label>
            </div>
            <div class="hint">Uncheck to generate only the sections you need. ‚ÄúAll‚Äù toggles everything.</div>
          </div>
          <div class="six">
            <div class="grid">
              <div class="six"><label for="v-tmin">Min (custom)</label><input id="v-tmin" type="number" min="1" max="300" disabled></div>
              <div class="six"><label for="v-tmax">Max (custom)</label><input id="v-tmax" type="number" min="1" max="300" disabled></div>
            </div>
          </div>
          <div class="twelve">
            <label for="v-vocab-include">Vocabulary to Include (optional)</label>
            <textarea id="v-vocab-include" rows="3" placeholder="Paste a full or partial list of words to include..."></textarea>
          </div>
        </div>
        <div class="actions">
          <button id="v-gen" class="primary">Generate Vocabulary</button>
          <button id="v-excel">Download Excel</button>
          <select id="v-copy-mode">
            <option value="" disabled selected>Copy‚Ä¶</option>
            <option value="all">Copy All</option>
            <option value="es-only">Copy Spanish Only</option>
          </select>
          <button id="v-prompt">Prompt</button>
          <div id="v-status" class="status"></div>
        </div>
      </div>
      <div id="v-output" class="output-container"><p>Your list will appear here...</p></div>`;
    $('gen-vocab').innerHTML = vocabUI;

    const genBtn = $('v-gen'),
          excelBtn = $('v-excel'),
          copySelect = $('v-copy-mode'),
          promptBtn = $('v-prompt'),
          statusEl = $('v-status'),
          outputEl = $('v-output'),
          planEl = $("v-plan"),
          tminEl = $("v-tmin"),
          tmaxEl = $("v-tmax"),
          presetTextEl = $("v-presetText"),
          topicEl = $("v-topic");

    const allBox = $('v-sec-all');
    const childBoxes = Array.from(document.querySelectorAll('.v-sec'));
    function setChildren(checked) { childBoxes.forEach(b => b.checked = checked); }
    function syncAll() { allBox.checked = childBoxes.every(b => b.checked); }
    allBox.addEventListener('change', () => setChildren(allBox.checked));
    childBoxes.forEach(b => b.addEventListener('change', syncAll));

    function getSelectedSections() {
      const vals = childBoxes.filter(b => b.checked).map(b => b.value);
      return new Set(vals); // possible values: nouns, verbs, adjectives, adverbs, phrases, questions
    }

    const presetRanges = {
      "1": { min:33, max:55 }, "2": { min:60, max:85 }, "3": { min:90, max:120 }, "4": { min:160, max:220 }, "5": { min:210, max:280 }
    };
    function updateUI() {
      const isCustom = planEl.value === 'custom';
      tminEl.disabled = !isCustom;
      tmaxEl.disabled = !isCustom;
      if (!isCustom) {
        const r = presetRanges[planEl.value];
        tminEl.value = r.min; tmaxEl.value = r.max;
        presetTextEl.textContent = `Preset for Word Count ${planEl.value}: ${r.min}‚Äì${r.max} total Spanish vocabulary items (target upper bound).`;
      } else {
        presetTextEl.textContent = `Custom: set Min/Max (1‚Äì300).`;
      }
    }
    planEl.addEventListener('change', updateUI);
    updateUI();

    function buildVocabInstruction() {
      let minCount, maxCount;
      if (planEl.value === 'custom') {
        minCount = Math.max(1, Math.min(300, Number(tminEl.value) || 1));
        maxCount = Math.max(minCount, Math.min(300, Number(tmaxEl.value) || minCount));
      } else {
        const r = presetRanges[planEl.value];
        minCount = r.min; maxCount = r.max;
      }
      const topic = (topicEl.value || '').trim();
      const sel = Array.from(getSelectedSections());
      const selLabel = sel.length ? sel.join(', ') : '(none)';

      return [
        `You are an expert assistant for the FCS program.`,
        `Topic: ‚Äú${topic}‚Äù.`,
        `Vocabulary range: ${minCount}‚Äì${maxCount} distinct Spanish vocabulary words (target the upper bound).`,
        `ABSOLUTE LENGTH COMPLIANCE: Produce at least ${minCount} and at most ${maxCount} total vocabulary items. Do not under-deliver.`,
        `Include ONLY these sections: ${selLabel}. Do NOT include or populate any other sections.`,
        `Organize the output into the selected parts only (subset of the following canonical 6):`,
        `1. Nouns ‚Äî ALWAYS subdivide into logical subcategories (e.g., People; Places; Objects/Equipment; Actions/Tools). Use subcategory header rows INSIDE the nouns table.`,
        `2. Verbs in Sentences`,
        `3. Adjectives`,
        `4. Adverbs`,
        `5. Common Phrases`,
        `6. Common Questions (no answers)`,
        `For any of Nouns/Verbs/Adjectives/Adverbs that are included, allocate counts so their sum stays within the requested range (target upper bound).`,
        `Include at least 10 Common Phrases and 10 Common Questions when those sections are included (increase counts for higher totals; keep each ‚â§10 if the system requests it).`,
        `For Nouns: use "the ..." in English. In Spanish, include the article (el, la) and if a noun has both masculine and feminine forms, include the feminine in parentheses (masculine form first).`,
        `For Adjectives and Adverbs: present each vocabulary item with its opposite (antonym) in a pair of sentences (first using the word, second using its antonym).`,
        `Highlight only the target verbs, adjectives, and adverbs in the sentences (do not color surrounding words or punctuation).`,
        `Formatting: Markdown tables; English | Espa√±ol; no HTML; alphabetize English within each subcategory; keep total within requested range; stay on topic.`,
        `Self-check counts internally before responding.`
      ].join('\n');
    }

    function buildVocabPrompt() {
      const rawPrompt = buildVocabInstruction();
      const topic = safeForScriptTemplate((topicEl.value || '').trim());

      // Selected sections -> build HTML skeleton dynamically
      const sel = getSelectedSections();
      // Helper to render a section block
      const sec = (title) => `
  <div class="section"><h2>${title}</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>`;

      let sectionsHTML = '';
      if (sel.has('nouns'))       sectionsHTML += sec('Nouns');
      if (sel.has('verbs'))       sectionsHTML += sec('Verbs in Sentences');
      if (sel.has('adjectives'))  sectionsHTML += sec('Adjectives');
      if (sel.has('adverbs'))     sectionsHTML += sec('Adverbs');
      if (sel.has('phrases'))     sectionsHTML += sec('Common Phrases');
      if (sel.has('questions'))   sectionsHTML += sec('Common Questions');

      const includeLine = `INCLUDE SECTIONS: ${Array.from(sel).join(',')}`;

      return `<!DOCTYPE html>
<!-- FCS VOCABULARY OUTPUT
  IMPORTANT: First internally answer the Markdown prompt below EXACTLY, then render the SAME content as styled HTML.
  ===== PROMPT =====
${rawPrompt}
  ==================
  RENDERING RULES:
  ‚Ä¢ Render ONLY the sections included below and leave all other sections out entirely.
  ‚Ä¢ Spanish vocabulary in colored spans where specified by your contract for included sections.
  ${includeLine}
-->
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Vocabulary ‚Äî ${topic}</title>
<style>
  :root{ --ink:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --bg:#ffffff; --en:#1a73e8; --es:#d93025; --h:#0f172a; }
  *{ box-sizing:border-box; }
  body{ font-family:Calibri,Arial,sans-serif; font-size:10pt; line-height:1.4; color:var(--ink); background:var(--bg); margin:0; }
  .fcs-doc{ max-width:980px; margin:0 auto; padding:24px; }
  h1{ font-size:20pt; text-align:center; color:var(--h); margin:0 0 12px 0; }
  h2{ font-size:13pt; color:var(--h); margin:16px 0 8px 0; text-align:center; }
  .section{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px; margin-top:14px; overflow-x:auto; }
  .tbl{ width:100%; border-collapse:separate; border-spacing:0; margin-top:10px; }
  .tbl th, .tbl td{ border:1px solid var(--border); padding:6px; vertical-align:top; }
  .tbl th{ background:#f5f7fb; font-weight:700; }
  .tbl tr:nth-child(even) td{ background:#fafafa; }
  .en{ color:var(--en); font-weight:700; } 
  .es{ color:var(--es); font-weight:700; }
</style></head>
<body><div class="fcs-doc" lang="en">
  <h1>Vocabulary: ${topic}</h1>
${sectionsHTML}
</div></body></html>`;
    }

    // Validator for Vocabulary output (respects section selection)
    function vocabValidator(html) {
      try {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const sel = Array.from(getSelectedSections());
        const map = {
          nouns: 'Nouns',
          verbs: 'Verbs in Sentences',
          adjectives: 'Adjectives',
          adverbs: 'Adverbs',
          phrases: 'Common Phrases',
          questions: 'Common Questions'
        };
        for (const key of sel) {
          const title = map[key];
          const h2 = Array.from(doc.querySelectorAll('h2')).find(h => h.textContent.trim().toLowerCase() === title.toLowerCase());
          if (!h2) return `Missing section: ${title}.`;
          const tbody = h2.parentElement.querySelector('tbody');
          if (!tbody || !tbody.querySelector('tr')) return `Section "${title}" has no rows.`;
          if (key === 'nouns') {
            const hasSubcats = Array.from(tbody.querySelectorAll('tr')).some(tr => {
              const th = tr.querySelector('th[colspan="2"]');
              const td = tr.querySelector('td[colspan="2"]');
              return !!(th || td);
            });
            if (!hasSubcats) return 'Nouns section must be subdivided into subcategories with header rows spanning both columns.';
          }
        }
        return "";
      } catch (e) {
        return "";
      }
    }

    $('v-gen').addEventListener('click', async () => {
      if (!topicEl.value.trim()) { statusEl.textContent = "Please enter a topic."; return; }
      const sel = getSelectedSections();
      if (sel.size === 0) { statusEl.textContent = "Please select at least one section."; return; }
      await generateAndRender(buildVocabPrompt(), $('v-gen'), $('v-status'), $('v-output'), vocabValidator, 0);
    });

    // Keep original "Prompt" copier intact
    $('v-prompt').addEventListener('click', () => {
  if (!topicEl.value.trim()) { 
    statusEl.textContent = "Please enter a topic."; 
    return; 
  }

  let minCount, maxCount;
  if (planEl.value === 'custom') {
    minCount = Math.max(1, Math.min(300, Number(tminEl.value) || 1));
    maxCount = Math.max(minCount, Math.min(300, Number(tmaxEl.value) || minCount));
  } else {
    const r = presetRanges[planEl.value];
    minCount = r.min; 
    maxCount = r.max;
  }

  const topic = (topicEl.value || '').trim();
  const selectedSections = Array.from(getSelectedSections());
  
  // Build prompt text based on selected sections
  let promptText = `You are an expert assistant for the FCS program.
 Explicit Instruction which is must to be followed: Do not give me code or html.
 You must always follow every instruction below exactly.
  Validation: Each section will be segregated into proper two columns English and Spanish of sufficiant width
 Never ask me follow-up questions, never stop early, and never skip or merge sections.
 For each conversation, the header must include both its number and a descriptive name that defines what the conversation is about. For example: ‚ÄúConversation 1 ‚Äî Asking for pool equipment‚Äù / ‚ÄúConversaci√≥n 1 ‚Äî Pidiendo equipo de piscina,‚Äù and ‚ÄúConversation 2 ‚Äî Making weekend swim plans‚Äù / ‚ÄúConversaci√≥n 2 ‚Äî Haciendo planes de nataci√≥n para el fin de semana.‚Äù Use the same format for both English and Spanish headers.
 Enforce two-column structure in all sections

All sections must always be presented in a two-column Markdown table. The left column is always English, the right column is always Spanish. Each header row must explicitly define the columns (example: ‚ÄúEnglish | Espa√±ol‚Äù). Never use one-column or mixed formatting.
Spacing & consistency reminder

Topic: ‚Äú${topic}‚Äù
 Vocabulary range: ${minCount}‚Äì${maxCount} distinct Spanish vocabulary words (target the upper bound).

0. Topic Title
At the very top, present the topic title in a two-column Markdown table row.


Title(For left side of column) and T√≠tulo(For left side of column)
 Topic in English(For left side of column) and Topic in Spanish(For left side of column)`;

  // Only include sections that are selected
  if (selectedSections.includes('nouns')) {
    promptText += `

1. Nouns
Present nouns in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
  Nouns(For left side of column) and Sustantivos(For right side of column) 


Use bold article + noun in both languages.


If more than 20 nouns, subdivide into logical categories such as People, Places, Equipment.


Only write ‚Äú1. Nouns‚Äù once at the start of this section, not before every subcategory.


Subcategories must have a short label such as People, Places.


Alphabetize English terms within each category.


All nouns must be relevant to the topic.


After each subcategory‚Äôs table, insert one completely blank row with just spaces,
 then the new section title, then one blank line before the new table begins.`;
  }

  if (selectedSections.includes('verbs')) {
    promptText += `

2. Verbs in Sentences
Present in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
 Verbs in Sentences(For left side of column) and Verbos en oraciones(For right side of column)


Always use third-person sentences in English with ‚Äúis/are going to + verb.‚Äù


Reflexive verbs must place the pronoun after the infinitive (example: va a descansarse).


Bold ‚Äúto + verb‚Äù in English and the infinitive in Spanish.


Include sentences where:


nouns from Part 1 are objects


nouns from Part 1 are subjects


no nouns, just a third-person subject (he, she, it, they)


Verbs must be relevant to the topic.


End the table with one completely blank row with just spaces, then the new section title, then another blank line.`;
  }

  if (selectedSections.includes('adjectives')) {
    promptText += `

3. Adjectives
Present in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
 Adjectives(For left side of column) and Adjetivos(For right side of column)


Sentences must pair nouns from Part 1 with ‚Äúis/are + adjective.‚Äù


Only the adjective should be bold.


Each major noun must appear with at least two adjectives (contrasting or related).


End with the same spacing rule.`;
  }

  if (selectedSections.includes('adverbs')) {
    promptText += `

4. Adverbs
Present in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
Adverbs(For left side of column) and Adverbios(For right side of column)


Sentences must reuse verbs from Part 2, each modified with an adverb.


Only the adverb should be bold.


Adverbs must fit the context of the topic.


End with the same spacing rule.`;
  }

  if (selectedSections.includes('phrases')) {
    promptText += `

5. Common Phrases
Present in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
Common Phrases(For left side of column) and Frases comunes(For right side of column)


Phrases must be relevant to the topic.


Write no more than 7 phrases.


End with the same spacing rule.`;
  }

  if (selectedSections.includes('questions')) {
    promptText += `

6. Common Questions
Present in a two-column Markdown table.


The header row must have column-specific descriptions, for example:
 Common Questions(For left side of column) and Preguntas comunes(For right side of column)


Do not include answers.


Write no more than 7 questions.


Questions must be relevant to the topic.


End with the same spacing rule.`;
  }

  // Always include Conversations and Monologue sections
  promptText += `

7. Conversations
Create two sample conversations in a two-column table.
Each Conversation to be seprated with Conversation 1 and Conversation 2 Title/ Header.

Each conversation is between two people.


Each conversation (1 & 2) must include 8 turns total (4 per person).


Each turn in each conversation (1 & 2) must contain 2‚Äì3 sentences/questions. (at least half of the turns include a question, and at least half of the turns include 3 sentences/questions


Each sentence in each turn in each conversation (1 & 2) must be 1‚Äì15 words long.


Conversations must include a natural mix of statements and questions.


Vary:


the number of sentences/questions per turn (sometimes 2, sometimes 3).


the length of sentences within a turn (some short, some longer).


Must use nouns, verbs, adjectives, and/or phrases from earlier sections.


Conversation 1 grammar rules: Do not use past tenses, subjunctive, or imperative.


Conversation 2 grammar rules: May use any grammar, verb tenses and moods.


Special formatting and spacing rules for Conversations:
After the line ‚Äú7. Conversations‚Äù, insert one completely blank row.


Then start Conversation 1 with a header row inside the table, with column-specific titles:


Left column: (English) Who is speaking/about what.


Right column: (Espa√±ol) Who is speaking/about what.


After Conversation 1‚Äôs table, insert two completely blank rows


Then Conversation 2 begins with its own header row inside the table, following the same column-specific titles.


After Conversation 2‚Äôs table, insert one completely blank row before the Monologue section.

8. Monologue
 Write a lecture-style monologue with 10‚Äì15 sentences.


Present in a two-column Markdown table.


It must be one paragraph, not separate lines.


It should feel like an explanation, guidance, or commentary about the topic.


Must use vocabulary from earlier sections.


Special formatting rule for Monologue:
 The header row of the table should contain column-specific titles:


Left column: ‚ÄúMonologue: [English description of topic]‚Äù


Right column: ‚ÄúMon√≥logo: [Spanish description of topic]‚Äù


‚ö† Both columns must contain a complete monologue: the left side in English and the right side in Spanish.


Final Rules
Use Markdown tables for all parts (0‚Äì8).


Every section must include a header row with column-specific descriptions, not just raw content.


After every table or subsection, always insert:


one completely blank row (just spaces),


then the new section title,


then one blank line before the next table.


Always produce the full 8 parts (title ‚Üí monologue).


Never stop early. Never ask me if you should continue.
Formatting: Markdown tables; English | Espa√±ol; no HTML; alphabetize English within each subcategory; keep total within requested range; stay on topic.`;

  copyText(promptText, statusEl);
});

    $('v-copy-mode').addEventListener('change', () => {
      const mode = $('v-copy-mode').value;
      if (!mode) return;
      copyContent(mode, $('v-output'), $('v-status'));
      $('v-copy-mode').selectedIndex = 0;
    });
    $('v-excel').addEventListener('click', () => downloadAsExcel($('v-output'), $('v-status'), $('v-topic').value || 'Vocabulary'));
  })();
})();
</script>
</body>
</html>
