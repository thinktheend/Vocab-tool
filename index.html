<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>FCS AI Generator Suite</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  :root { --bg:#f7f9fc; --fg:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --accent:#0b5cff;
          --en:#1a73e8; --es:#d93025; --head:#0f172a; }
  body { background: var(--bg); color: var(--fg); font-family: Calibri, Arial, sans-serif; font-size: 15px; margin:0; }
  .fcs-wrap { max-width: 980px; margin: 28px auto; padding: 0 16px; }
  h1 { font-size: 28px; font-weight:700; text-align:center; margin-bottom: 28px; color: var(--head); }
  h2 { font-size: 20px; font-weight:700; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; color: var(--head); }
  .fcs-card { border:1px solid var(--border); border-radius: 12px; padding: 24px; background:var(--panel); margin-bottom: 20px; }
  label { font-weight: 600; font-size: 14px; display: block; margin-bottom: 6px; }
  input[type="text"], select, input[type="number"], textarea { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: #fff; font-size:15px; box-sizing:border-box; }
  input:disabled { background-color: #f8f9fa; }
  .hint, .small { font-size: 12px; color: var(--muted); margin-top: 4px; }
  button { padding: 10px 16px; border-radius: 8px; border:1px solid var(--border); background:#f6f8fb; cursor: pointer; font-weight: 600; font-size:15px; transition: all 0.2s; }
  button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
  button:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.08); }
  button:disabled { cursor: not-allowed; opacity: 0.6; }
  .fcs-tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
  .fcs-tab-btn { flex-grow: 1; text-align: center; } .fcs-generator { display: none; } .fcs-generator.active { display: block; }
  .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 16px; align-items: end; }
  .six { grid-column: span 6; } .twelve { grid-column: span 12; }
  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; } .grid-full { grid-column: 1 / -1; }
  .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top:20px; align-items:center; }
  .status { margin-top:10px; min-height:1.5em; text-align:left; color:var(--muted); font-size:13px; }
  .output-container { border:1px solid var(--border); border-radius:12px; padding:24px; background:#fff; min-height: 240px; margin-top:12px; }
  .output-container h1, .output-container h2 { text-align: center; color: #0f172a !important; }
  .output-container table { width:100%; border-collapse: separate; border-spacing: 0; margin-top: 12px; font-size:10pt; }
  .output-container th, .output-container td { border:1px solid #e5e7eb; padding:8px; vertical-align:top; }
  .output-container th { background: #f5f7fb; }
  .output-container tr:nth-child(even) td { background: #fafafa; }
  .output-container .en { color: var(--en); font-weight: bold; }
  .output-container .es { color: var(--es); font-weight: bold; }
  .output-container .full-black { color: var(--fg); font-weight: 700; }

  .tts-line-btn { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; margin-right:6px; border:1px solid #dbe2ef;
    border-radius:999px; background:#eef2ff; cursor:pointer; font-size:12px; line-height:1; }
  .tts-line-btn[data-tts="es"] { background:#fdeaea; border-color:#f5c2c7; }
  .tts-line-btn:hover { filter:brightness(0.98); }

  .conv-ctrls { display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
  .conv-ctrls button { padding:6px 10px; font-size:12px; }

  /* NEW: Global conversation audio controls */
  .conv-global-ctrls { display:flex; gap:8px; align-items:center; justify-content:center; margin:10px 0 16px; }
  .conv-global-ctrls button { padding:8px 12px; font-size:13px; }

  @media (max-width: 860px){ .six, .twelve { grid-column: span 12; } .grid-2 { grid-template-columns:1fr; } }
</style>
</head>
<body>
<div class="fcs-wrap">
  <h1>FCS AI GENERATOR SUITE</h1>
  <div class="fcs-tabs">
    <button id="tab-vocab" class="fcs-tab-btn primary">Vocabulary</button>
    <button id="tab-convo" class="fcs-tab-btn">Conversation</button>
    <button id="tab-test" class="fcs-tab-btn">Test</button>
  </div>

  <div id="gen-vocab" class="fcs-generator active"></div>
  <div id="gen-convo" class="fcs-generator"></div>
  <div id="gen-test" class="fcs-generator"></div>
</div>

<script>
"use strict";
(function(){
  const $ = id => document.getElementById(id);
  const API_URL = "/api/index";

  /* ---------- Helpers ---------- */
  function decodeIfEscaped(html) {
    const s = String(html || '');
    if(/&lt;(!DOCTYPE|html|head|body|div|table|h1|h2)/i.test(s)) {
      const ta = document.createElement('textarea');
      ta.innerHTML = s;
      return ta.value;
    }
    return s;
  }
  function extractDocHTML(html) {
    const parsed = new DOMParser().parseFromString(html, 'text/html');
    let node = parsed.querySelector('.fcs-doc') || parsed.body || parsed.documentElement;
    node.querySelectorAll('script').forEach(s => s.remove());
    return node.innerHTML || '';
  }
  function renderGenerated(html, container) {
    const normalized = decodeIfEscaped(html);
    const safeInner = extractDocHTML(normalized);
    container.innerHTML = safeInner || normalized;
  }
  const safeForScriptTemplate = s => String(s || '').replace(/<\/script/gi,'<\\/script');

  // Lightweight TTS
  const Speech = (function() {
    let voices = [], ready = false;
    function load() { voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : []; return voices.length > 0; }
    async function ensure() {
      if (!('speechSynthesis' in window)) return [];
      if (ready && voices.length) return voices;
      if (load()) { ready = true; return voices; }
      return new Promise(res => {
        const h = () => { if (load()) { ready = true; window.speechSynthesis.onvoiceschanged = null; res(voices); } };
        window.speechSynthesis.onvoiceschanged = h; setTimeout(h, 800);
      });
    }
    function pick(lang, idx=0) {
      const L = String(lang || '').toLowerCase();
      const all = voices.filter(v => v.lang.toLowerCase().startsWith(L.split('-')[0]));
      if (all.length === 0) return null;
      return all[idx % all.length] || all[0];
    }
    function speak(text, opts) {
      if (!('speechSynthesis' in window)) return;
      const t = (text || '').replace(/\s+/g, ' ').trim(); if (!t) return;
      const u = new SpeechSynthesisUtterance(t);
      u.lang = opts?.lang || 'es-ES';
      if (opts?.voice) u.voice = opts.voice;
      if (typeof opts?.rate === 'number') u.rate = opts.rate;
      if (typeof opts?.pitch === 'number') u.pitch = opts.pitch;
      if (typeof opts?.volume === 'number') u.volume = opts.volume;
      window.speechSynthesis.speak(u);
      return u;
    }
    return { ensure, speak, pick };
  })();

  function cleanCellText(cell) {
    return (cell.innerText || '').replace(/^\s*üîä\s*(EN|ES)\s*/, '').trim();
  }

  /* Per-line TTS buttons (unchanged) */
  function addPerLineTTS(root) {
    if (!root || !('speechSynthesis' in window)) return;
    root.querySelectorAll('table tbody tr').forEach(tr => {
      const tds = tr.querySelectorAll('td');
      if (tds.length < 2) return;
      ['en','es'].forEach((lang, idx) => {
        const cell = tds[idx];
        if (!cell || cell.querySelector('.tts-line-btn')) return;
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'tts-line-btn'; btn.dataset.tts = lang;
        btn.textContent = 'üîä ' + (lang === 'en' ? 'EN' : 'ES');
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const text = cleanCellText(cell);
          Speech.speak(text, { lang: lang === 'es' ? 'es-ES' : 'en-US', rate: 1 });
        });
        cell.insertBefore(btn, cell.firstChild);
      });
    });
  }

  /* Per-conversation controls (unchanged EN+ES) */
  function addConversationGlobalTTS(root) {
    if (!root || !('speechSynthesis' in window)) return;
    const sections = Array.from(root.querySelectorAll('.section')).filter(sec => {
      const h2 = sec.querySelector('h2');
      return h2 && /^Conversation\s+\d+/i.test(h2.textContent.trim());
    });
    sections.forEach(sec => {
      if (sec.querySelector('.conv-ctrls')) return;
      const ctrl = document.createElement('div');
      ctrl.className = 'conv-ctrls';
      ctrl.innerHTML = `<button type="button" data-act="play">‚ñ∂ Play All (EN+ES)</button>
                        <button type="button" data-act="pause">‚è∏ Pause</button>
                        <button type="button" data-act="stop">‚èπ Stop</button>`;
      sec.insertBefore(ctrl, sec.querySelector('table'));

      let queue = [], idx = 0, playing = false;

      function buildQueue() {
        queue = [];
        const rows = sec.querySelectorAll('tbody tr');
        rows.forEach(tr => {
          const tds = tr.querySelectorAll('td');
          if (tds.length < 2) return;
          const en = cleanCellText(tds[0]);
          const es = cleanCellText(tds[1]);
          if (en) queue.push({ text: en, lang: 'en-US' });
          if (es) queue.push({ text: es, lang: 'es-ES' });
        });
      }
      function speakNext() {
        if (!playing) return;
        if (idx >= queue.length) { playing = false; return; }
        const { text, lang } = queue[idx++];
        const u = Speech.speak(text, { lang });
        u.onend = () => speakNext();
      }

      ctrl.querySelector('[data-act="play"]').addEventListener('click', async () => {
        await Speech.ensure();
        window.speechSynthesis.cancel();
        buildQueue(); idx = 0; playing = true;
        speakNext();
      });
      ctrl.querySelector('[data-act="pause"]').addEventListener('click', () => {
        if (window.speechSynthesis.paused) { window.speechSynthesis.resume(); }
        else { window.speechSynthesis.pause(); }
      });
      ctrl.querySelector('[data-act="stop"]').addEventListener('click', () => {
        playing = false; window.speechSynthesis.cancel();
      });
    });
  }

  /* NEW: Global Spanish-only controls that omit speaker names and vary sound between speakers */
  function addGlobalSpanishControls(root) {
    if (!root || !('speechSynthesis' in window)) return;
    if (root.querySelector('.conv-global-ctrls')) return;

    const bar = document.createElement('div');
    bar.className = 'conv-global-ctrls';
    bar.innerHTML = `
      <button type="button" data-act="play-es">‚ñ∂ Play Spanish (All Conversations)</button>
      <button type="button" data-act="pause-es">‚è∏ Pause</button>
      <button type="button" data-act="stop-es">‚èπ Stop</button>`;
    root.prepend(bar);

    let queue = [], idx = 0, playing = false;

    function stripSpeakerName(t) {
      return t.replace(/^\s*\[[^\]]+\]\s*/, '').trim();
    }

    function voiceForSpeaker(speaker, indexHint=0) {
      const base = Speech.pick('es-ES', indexHint) || Speech.pick('es', indexHint);
      const hash = speaker ? speaker.charCodeAt(0) + speaker.length : indexHint;
      const variant = hash % 2; // two variants for contrast
      const pitch = variant === 0 ? 1.0 : 1.2;
      const rate  = variant === 0 ? 1.0 : 0.92;
      return { voice: base, pitch, rate, volume: 1, lang: 'es-ES' };
    }

    function buildQueueSpanish() {
      queue = [];
      const convSections = Array.from(root.querySelectorAll('.section')).filter(sec => {
        const h2 = sec.querySelector('h2'); return h2 && /^Conversation\s+\d+/i.test(h2.textContent.trim());
      });

      convSections.forEach(sec => {
        const rows = sec.querySelectorAll('tbody tr');
        rows.forEach(tr => {
          const tds = tr.querySelectorAll('td');
          if (tds.length < 2) return;
          const esFull = cleanCellText(tds[1]);
          if (!esFull) return;
          const firstBracket = (tds[1].innerText || '').match(/^\s*\[([^\]]+)\]/);
          const speaker = firstBracket ? firstBracket[1].trim().toLowerCase() : '';
          const text = stripSpeakerName(esFull);
          queue.push({ text, speaker });
        });
      });
    }

    function speakNext() {
      if (!playing) return;
      if (idx >= queue.length) { playing = false; return; }
      const item = queue[idx++];
      const opts = voiceForSpeaker(item.speaker, idx);
      const u = Speech.speak(item.text, opts);
      if (u) u.onend = () => speakNext();
      else setTimeout(speakNext, 50);
    }

    bar.querySelector('[data-act="play-es"]').addEventListener('click', async () => {
      await Speech.ensure();
      window.speechSynthesis.cancel();
      buildQueueSpanish();
      idx = 0; playing = true; speakNext();
    });
    bar.querySelector('[data-act="pause-es"]').addEventListener('click', () => {
      if (window.speechSynthesis.paused) { window.speechSynthesis.resume(); }
      else { window.speechSynthesis.pause(); }
    });
    bar.querySelector('[data-act="stop-es"]').addEventListener('click', () => {
      playing = false; window.speechSynthesis.cancel();
    });
  }

  // Shared sentence splitter
  function splitIntoSentences(text) {
    const norm = String(text || '').replace(/\s+/g, ' ').trim();
    if (!norm) return [];
    const parts = norm.match(/[^.!?]+[.!?]?/g) || [];
    return parts.map(s => s.trim()).filter(Boolean);
  }

  /* ===== Level rules (Conversation) ‚Äî UPDATED to user's spec ===== */
  function getLevelRulesLines(level) {
    switch (String(level)) {
      case '1': return [
        'LEVEL 1 ‚Äì Fluent Reading & Pronunciation (MUST FOLLOW):',
        '‚Ä¢ Long scripted conversation provided (student does not create).',
        '‚Ä¢ Must read smoothly, with correct stress and intonation.',
        '‚Ä¢ No grammar production required ‚Äî purely recognition and oral delivery.',
        '‚Ä¢ Includes full range of topic vocabulary.',
        'Pass Criteria: natural speed; ‚â•90% correct pronunciation; rising intonation for questions.'
      ];
      case '2': return [
        'LEVEL 2 ‚Äì Present Tense, Reflexives & Glue Words (MUST FOLLOW):',
        '‚Ä¢ Ser/Estar correctly (characteristics vs. states/locations).',
        '‚Ä¢ Present tense with all regular verbs.',
        '‚Ä¢ Phrases: tener que, necesitar, querer, ir a, poder, acabar de, gustar.',
        '‚Ä¢ Conditional with: poder, gustar, deber.',
        '‚Ä¢ Object pronouns (direct & indirect).',
        '‚Ä¢ Reflexive verbs in present tense.',
        '‚Ä¢ Glue words: prepositions, conjunctions, adverbs, subject/pronouns, possessives/demonstratives, comparisons, quantities, time words.'
      ];
      case '3': return [
        'LEVEL 3 ‚Äì Adds Past Tenses & Progressive (MUST FOLLOW):',
        '‚Ä¢ All Level 2 requirements.',
        '‚Ä¢ Present (incl. irregulars).',
        '‚Ä¢ Pret√©rito for completed past actions.',
        '‚Ä¢ Imperfecto for ongoing/habitual past actions.',
        '‚Ä¢ Present progressive (estar + gerund).'
      ];
      case '4': return [
        'LEVEL 4 ‚Äì Adds Future, Conditionals, Perfects & All Uses of ‚ÄúSe‚Äù (MUST FOLLOW):',
        '‚Ä¢ All Level 2 & 3 requirements.',
        '‚Ä¢ Simple future; simple conditional.',
        '‚Ä¢ Present perfect; present perfect progressive.',
        '‚Ä¢ ‚ÄúSe‚Äù constructions: passive, impersonal, object-pronoun substitutions, reflexives, irse, intensifying, accidental (se me ‚Ä¶), reciprocal.'
      ];
      case '5': return [
        'LEVEL 5 ‚Äì Adds Imperatives, Subjunctive, Expanded Progressives & Perfects (MUST FOLLOW):',
        '‚Ä¢ All Level 2‚Äì4 requirements.',
        '‚Ä¢ Imperatives (positive & negative).',
        '‚Ä¢ Subjunctive (present & past).',
        '‚Ä¢ Progressives in present, future, conditional, preterite, imperfect.',
        '‚Ä¢ Perfects in present, future, conditional, preterite, imperfect.',
        '‚Ä¢ Perfect progressives in those tenses.'
      ];
      case '6': return [
        'LEVEL 6 ‚Äì Native Level (MUST FOLLOW):',
        '‚Ä¢ All grammar and vocabulary from Levels 2‚Äì5.',
        '‚Ä¢ Native-level fluency, idiomatic expressions, nuanced usage.',
        '‚Ä¢ Maintain all format and length constraints.'
      ];
      default: return [];
    }
  }

  /* =========================
     Vocabulary Generator (UNCHANGED)
     ========================= */
  (function setupVocab() {
    /* ############## DO NOT TOUCH ‚Äî unchanged UI/logic for Vocabulary ############## */
    const vocabUI = 
      `<div class="fcs-card">
        <h2>Vocabulary Creator</h2>
        <div class="grid">
          <div class="six"><label for="v-topic">Topic</label><input id="v-topic" type="text" placeholder="e.g., At the Airport"></div>
          <div class="six"><label for="v-plan">Word Count Plan</label>
            <select id="v-plan">
              <option value="1" selected>Word Count 1</option>
              <option value="2">Word Count 2</option>
              <option value="3">Word Count 3</option>
              <option value="4">Word Count 4</option>
              <option value="5">Word Count 5</option>
              <option value="custom">Custom</option>
            </select>
            <div id="v-presetText" class="hint"></div>
          </div>
          <div class="twelve">
            <label>Sections to Include (multi-select)</label>
            <div id="v-sections" style="display:flex; flex-wrap:wrap; gap:14px;">
              <label><input type="checkbox" id="v-sec-all" checked> All</label>
              <label><input type="checkbox" class="v-sec" value="nouns" checked> Nouns</label>
              <label><input type="checkbox" class="v-sec" value="verbs" checked> Verbs</label>
              <label><input type="checkbox" class="v-sec" value="adjectives" checked> Adjectives</label>
              <label><input type="checkbox" class="v-sec" value="adverbs" checked> Adverbs</label>
              <label><input type="checkbox" class="v-sec" value="phrases" checked> Common Phrases</label>
              <label><input type="checkbox" class="v-sec" value="questions" checked> Common Questions</label>
            </div>
            <div class="hint">Uncheck to generate only the sections you need. ‚ÄúAll‚Äù toggles everything.</div>
          </div>
          <div class="six">
            <div class="grid">
              <div class="six"><label for="v-tmin">Min (custom)</label><input id="v-tmin" type="number" min="1" max="300" disabled></div>
              <div class="six"><label for="v-tmax">Max (custom)</label><input id="v-tmax" type="number" min="1" max="300" disabled></div>
            </div>
          </div>
          <div class="twelve">
            <label for="v-vocab-include">Vocabulary to Include (optional)</label>
            <textarea id="v-vocab-include" rows="3" placeholder="Paste a full or partial list of words to include..."></textarea>
          </div>
        </div>
        <div class="actions">
          <button id="v-gen" class="primary">Generate Vocabulary</button>
          <button id="v-excel">Download Excel</button>
          <select id="v-copy-mode">
            <option value="" disabled selected>Copy‚Ä¶</option>
            <option value="all">Copy All</option>
            <option value="es-only">Copy Spanish Only</option>
          </select>
          <button id="v-prompt">Prompt</button>
          <div id="v-status" class="status"></div>
        </div>
      </div>
      <div id="v-output" class="output-container"><p>Your list will appear here...</p></div>`;
    $('gen-vocab').innerHTML = vocabUI;

    const genBtn = $('v-gen'),
          excelBtn = $('v-excel'),
          copySelect = $('v-copy-mode'),
          promptBtn = $('v-prompt'),
          statusEl = $('v-status'),
          outputEl = $('v-output'),
          planEl = $("v-plan"),
          tminEl = $("v-tmin"),
          tmaxEl = $("v-tmax"),
          presetTextEl = $("v-presetText"),
          topicEl = $("v-topic");

    const allBox = $('v-sec-all');
    const childBoxes = Array.from(document.querySelectorAll('.v-sec'));
    function setChildren(checked) { childBoxes.forEach(b => b.checked = checked); }
    function syncAll() { allBox.checked = childBoxes.every(b => b.checked); }
    allBox.addEventListener('change', () => setChildren(allBox.checked));
    childBoxes.forEach(b => b.addEventListener('change', syncAll));

    const presetRanges = {
      "1": { min:33, max:55 }, "2": { min:60, max:85 }, "3": { min:90, max:120 }, "4": { min:160, max:220 }, "5": { min:210, max:280 }
    };
    function updateUI() {
      const isCustom = planEl.value === 'custom';
      tminEl.disabled = !isCustom;
      tmaxEl.disabled = !isCustom;
      if (!isCustom) {
        const r = presetRanges[planEl.value];
        tminEl.value = r.min; tmaxEl.value = r.max;
        presetTextEl.textContent = `Preset for Word Count ${planEl.value}: ${r.min}‚Äì${r.max} total Spanish vocabulary items (target upper bound).`;
      } else {
        presetTextEl.textContent = `Custom: set Min/Max (1‚Äì300).`;
      }
    }
    planEl.addEventListener('change', updateUI);
    updateUI();

    function buildVocabInstruction() {
      let minCount, maxCount;
      if (planEl.value === 'custom') {
        minCount = Math.max(1, Math.min(300, Number(tminEl.value) || 1));
        maxCount = Math.max(minCount, Math.min(300, Number(tmaxEl.value) || minCount));
      } else {
        const r = presetRanges[planEl.value];
        minCount = r.min; maxCount = r.max;
      }
      const topic = (topicEl.value || '').trim();
      return [
        `You are an expert assistant for the FCS program.`,
        `Topic: ‚Äú${topic}‚Äù.`,
        `Vocabulary range: ${minCount}‚Äì${maxCount} distinct Spanish vocabulary words (target the upper bound).`,
        `ABSOLUTE LENGTH COMPLIANCE: Produce at least ${minCount} and at most ${maxCount} total vocabulary items. Do not under-deliver.`,
        `Organize the output into 6 parts:`,
        `1. Nouns ‚Äî ALWAYS subdivide into logical subcategories (e.g., People; Places; Objects/Equipment; Actions/Tools). Use subcategory header rows INSIDE the nouns table.`,
        `2. Verbs in Sentences`,
        `3. Adjectives`,
        `4. Adverbs`,
        `5. Common Phrases`,
        `6. Common Questions (no answers)`,
        `Allocate roughly 30% of the total vocabulary to Nouns, 30% to Verbs, 15% to Adjectives, and 15% to Adverbs (by count of Spanish terms). Indicate the count of items in each section and noun subcategory heading.`,
        `Include at least 10 Common Phrases and 10 Common Questions (increase counts for higher vocabulary totals).`,
        `For Nouns: use "the ..." in English. In Spanish, include the article (el, la) and if a noun has both masculine and feminine forms, include the feminine in parentheses (masculine form first).`,
        `For Adjectives and Adverbs: present each vocabulary item with its opposite (antonym) in a pair of sentences (first using the word, second using its antonym).`,
        `Highlight only the target verbs, adjectives, and adverbs in the sentences (do not color surrounding words or punctuation).`,
        `Formatting: Markdown tables; English | Espa√±ol; no HTML; alphabetize English within each subcategory; keep total within requested range; stay on topic.`,
        `Self-check counts internally before responding.`
      ].join('\n');
    }

    function buildVocabPrompt() {
      const rawPrompt = buildVocabInstruction();
      const topic = safeForScriptTemplate((topicEl.value || '').trim());
      return `<!DOCTYPE html>
<!-- FCS VOCABULARY OUTPUT
  IMPORTANT: First internally answer the Markdown prompt below EXACTLY, then render the SAME content as styled HTML.
  ===== PROMPT =====
${rawPrompt}
  ==================
  RENDERING RULES:
  ‚Ä¢ 6 sections, each with a single 2-col table (English | Espa√±ol) in this order:
    1) Nouns; 2) Verbs in Sentences; 3) Adjectives; 4) Adverbs; 5) Common Phrases; 6) Common Questions
  ‚Ä¢ Nouns section MUST contain subcategory header rows (colspan=2), one per subcategory.
  ‚Ä¢ Spanish vocabulary in colored spans where specified by your contract for sections 1‚Äì4.
-->
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Vocabulary ‚Äî ${topic}</title>
<style>
  :root{ --ink:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --bg:#ffffff; --en:#1a73e8; --es:#d93025; --h:#0f172a; }
  *{ box-sizing:border-box; }
  body{ font-family:Calibri,Arial,sans-serif; font-size:10pt; line-height:1.4; color:var(--ink); background:var(--bg); margin:0; }
  .fcs-doc{ max-width:980px; margin:0 auto; padding:24px; }
  h1{ font-size:20pt; text-align:center; color:var(--h); margin:0 0 12px 0; }
  h2{ font-size:13pt; color:var(--h); margin:16px 0 8px 0; text-align:center; }
  .section{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px; margin-top:14px; overflow-x:auto; }
  .tbl{ width:100%; border-collapse:separate; border-spacing:0; margin-top:10px; }
  .tbl th, .tbl td{ border:1px solid var(--border); padding:6px; vertical-align:top; }
  .tbl th{ background:#f5f7fb; font-weight:700; }
  .tbl tr:nth-child(even) td{ background:#fafafa; }
  .en{ color:var(--en); font-weight:700; } 
  .es{ color:var(--es); font-weight:700; }
</style></head>
<body><div class="fcs-doc" lang="en">
  <h1>Vocabulary: ${topic}</h1>

  <div class="section"><h2>Nouns</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section"><h2>Verbs in Sentences</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section"><h2>Adjectives</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section"><h2>Adverbs</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section"><h2>Common Phrases</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section"><h2>Common Questions</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
</div></body></html>`;
    }

    // Validator for Vocabulary output (unchanged)
    function vocabValidator(html) {
      try {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const titles = ['Nouns','Verbs in Sentences','Adjectives','Adverbs','Common Phrases','Common Questions'];
        for (const t of titles) {
          const h2 = Array.from(doc.querySelectorAll('h2')).find(h => h.textContent.trim().toLowerCase() === t.toLowerCase());
          if (!h2) return `Missing section: ${t}.`;
          const tbody = h2.parentElement.querySelector('tbody');
          if (!tbody || !tbody.querySelector('tr')) return `Section "${t}" has no rows.`;
          if (t === 'Nouns') {
            const hasSubcats = Array.from(tbody.querySelectorAll('tr')).some(tr => {
              const th = tr.querySelector('th[colspan="2"]');
              const td = tr.querySelector('td[colspan="2"]');
              return !!(th || td);
            });
            if (!hasSubcats) return 'Nouns section must be subdivided into subcategories with header rows spanning both columns.';
          }
        }
        return "";
      } catch (e) {
        return "";
      }
    }

    $('v-gen').addEventListener('click', async () => {
      if (!topicEl.value.trim()) { statusEl.textContent = "Please enter a topic."; return; }
      await generateAndRender(buildVocabPrompt(), $('v-gen'), $('v-status'), $('v-output'), vocabValidator, 0);
    });

    $('v-prompt').addEventListener('click', () => {
      if (!topicEl.value.trim()) { 
        $('v-status').textContent = "Please enter a topic.";
        return; 
      }
      const promptText = buildVocabInstruction();
      copyText(promptText, $('v-status'));
    });

    $('v-copy-mode').addEventListener('change', () => {
      const mode = $('v-copy-mode').value;
      if (!mode) return;
      copyContent(mode, $('v-output'), $('v-status'));
      $('v-copy-mode').selectedIndex = 0;
    });
    $('v-excel').addEventListener('click', () => downloadAsExcel($('v-output'), $('v-status'), $('v-topic').value || 'Vocabulary'));
  })();

  /* =========================
     Conversation Generator (UPDATED)
     ========================= */
  (function setupConvo() {
    const convoUI = 
      `<div class="fcs-card"><h2>Conversation Creator</h2>
        <div class="grid-2">
          <div class="grid-full"><label for="c-topic">Topic</label><input id="c-topic" type="text" placeholder="e.g., A funny story about a vacation"/></div>

          <div><label>Level (Grammar)</label>
            <select id="c-level">
              <option value="1" selected>Level 1 ‚Äî Fluent Reading & Pronunciation</option>
              <option value="2">Level 2 ‚Äî Present + Reflexives + Glue Words</option>
              <option value="3">Level 3 ‚Äî Past + Progressive</option>
              <option value="4">Level 4 ‚Äî Future/Conditionals/Perfects/‚ÄúSe‚Äù</option>
              <option value="5">Level 5 ‚Äî Imperatives & Subjunctive (+ All Progressives/Perfects)</option>
              <option value="6">Level 6 ‚Äî Native</option>
            </select>
          </div>

          <div><label>Mode</label>
            <select id="c-mode">
              <option value="dialogue" selected>Dialogue</option>
              <option value="monologue">Monologue</option>
            </select>
            <div class="hint">Monologue locks: 1 conversation, 1 speaker, 1 turn, longest length.</div>
          </div>

          <div><label># of Conversations</label><input id="c-numConvos" type="number" value="1" min="1"/></div>
          <div><label># of Speakers</label><input id="c-numSpeakers" type="number" value="2" min="1"/></div>

          <div class="grid-full" style="display:grid; grid-template-columns: repeat(2, 1fr); gap:12px;">
            <div><label>Turns</label><input id="c-turns" type="number" value="10" min="1"/></div>
            <div>
              <label for="c-length">Output length</label>
              <select id="c-length">
                <option value="shortest">Shortest (1‚Äì2 ES sentences / 1‚Äì10 words)</option>
                <option value="short">Short (1‚Äì2 ES sentences / 6‚Äì20 words)</option>
                <option value="mediumShort" selected>Medium short (2‚Äì3 ES sentences / 6‚Äì20 words)</option>
                <option value="mediumLong">Medium long (3‚Äì4 ES sentences / 6‚Äì20 words)</option>
                <option value="long">Long (4‚Äì5 ES sentences / 6‚Äì20 words)</option>
                <option value="longest">Longest (15‚Äì30 ES sentences / 6‚Äì20 words)</option>
              </select>
            </div>
          </div>

          <div><label>Tone</label>
            <select id="c-tone">
              <option>Neutral, casual</option>
              <option>Informal, friendly</option>
              <option>Instructor, student</option>
              <option>Customer, staff</option>
              <option>Professional, formal</option>
              <option>Street slang</option>
            </select>
          </div>
          <div><label>Country / Region</label><select id="c-country"></select></div>

          <div class="grid-full">
            <label>Fill-in-the-Blank Options</label>
            <div id="c-fib-group" style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
              <label><input type="checkbox" id="c-fib-none" checked> none</label>
              <label><input type="checkbox" id="c-fib-mixed"> mixed</label>
              <label><input type="checkbox" class="fib-opt" value="nouns"> nouns</label>
              <label><input type="checkbox" class="fib-opt" value="verbs"> verbs</label>
              <label><input type="checkbox" class="fib-opt" value="adjectives/adverbs"> adjectives/adverbs</label>
              <label><input type="checkbox" class="fib-opt" value="pronouns"> pronouns (object pronouns)</label>
              <label><input type="checkbox" class="fib-opt" value="glue words"> glue words</label>
            </div>
            <div class="hint">
              ‚Äúmixed‚Äù checks all options; ‚Äúnone‚Äù clears them. Glue words: possessive/demonstratives, conjunctions, adverbs, quantifiers, prepositions, comparisons.
            </div>
          </div>

          <div class="grid-full"><label for="c-vocab">Vocabulary (optional)</label><textarea id="c-vocab" rows="6" placeholder="Put your own vocabulary here..."></textarea></div>
          <div class="grid-full"><label>Optional Teacher Notes</label><textarea id="c-notes" rows="4"></textarea></div>
        </div>
        <div class="actions">
          <button id="c-gen" class="primary">Generate</button>
          <button id="c-excel">Excel</button>
          <select id="c-copy-mode">
            <option value="" disabled selected>Copy‚Ä¶</option>
            <option value="all">Copy All</option>
            <option value="es-only">Copy Spanish Only</option>
          </select>
          <button id="c-prompt">Prompt</button>
          <div id="c-status" class="status"></div>
        </div>
      </div>
      <div id="c-output" class="output-container"><p>Your conversation appears here...</p></div>`;
    $('gen-convo').innerHTML = convoUI;

    const countrySelect = $('c-country');
    const countries = ["-no specific-", "Argentina", "Bolivia", "Chile", "Colombia", "Costa Rica", "Cuba", "Dominican Republic", "Ecuador", "El Salvador", "Equatorial Guinea", "Guatemala", "Honduras", "Mexico", "Nicaragua", "Panama", "Paraguay", "Peru", "Puerto Rico", "Spain", "Uruguay", "Venezuela"];
    countrySelect.innerHTML = countries.map(c => `<option>${c}</option>`).join('');

    const genBtn = $('c-gen'),
          excelBtn = $('c-excel'),
          copySelect = $('c-copy-mode'),
          promptBtn = $('c-prompt'),
          statusEl = $('c-status'),
          outputEl = $('c-output');

    // Presets for output length
    const LENGTH_PRESETS = {
      shortest:    { minSent:1, maxSent:2,  minWords:1,  maxWords:10 },
      short:       { minSent:1, maxSent:2,  minWords:6,  maxWords:20 },
      mediumShort: { minSent:2, maxSent:3,  minWords:6,  maxWords:20 },
      mediumLong:  { minSent:3, maxSent:4,  minWords:6,  maxWords:20 },
      long:        { minSent:4, maxSent:5,  minWords:6,  maxWords:20 },
      longest:     { minSent:15, maxSent:30, minWords:6,  maxWords:20 }
    };
    const getLengthPreset = () => LENGTH_PRESETS[$('c-length').value || 'mediumShort'] || LENGTH_PRESETS.mediumShort;

    // FIB toggles
    const noneBox = $('c-fib-none');
    const mixedBox = $('c-fib-mixed');
    const fibBoxes = Array.from(document.querySelectorAll('#c-fib-group .fib-opt'));
    function syncFibFromNone() {
      if (noneBox.checked) {
        mixedBox.checked = false;
        fibBoxes.forEach(b => b.checked = false);
      }
    }
    function syncFibFromMixed() {
      if (mixedBox.checked) {
        noneBox.checked = false;
        fibBoxes.forEach(b => b.checked = true);
      }
    }
    function syncFibFromOption() {
      if (fibBoxes.some(b => b.checked)) {
        noneBox.checked = false;
        mixedBox.checked = fibBoxes.every(b => b.checked);
      } else {
        noneBox.checked = true;
        mixedBox.checked = false;
      }
    }
    noneBox.addEventListener('change', syncFibFromNone);
    mixedBox.addEventListener('change', syncFibFromMixed);
    fibBoxes.forEach(b => b.addEventListener('change', syncFibFromOption));

    function getSelectedFIB() {
      const tags = fibBoxes.filter(b => b.checked).map(b => b.value);
      const active = tags.length > 0 && !noneBox.checked;
      const label = active ? tags.join(', ') : 'none';
      return { active, tags, label };
    }

    // Mode: Dialogue / Monologue
    function applyModeLocking() {
      const mode = $('c-mode').value;
      if (mode === 'monologue') {
        $('c-numConvos').value = 1;
        $('c-numConvos').disabled = true;
        $('c-numSpeakers').value = 1;
        $('c-numSpeakers').disabled = true;
        $('c-turns').value = 1;
        $('c-turns').disabled = true;
        $('c-length').value = 'longest';
        $('c-length').disabled = true;
      } else {
        $('c-numConvos').disabled = false;
        $('c-numSpeakers').disabled = false;
        $('c-turns').disabled = false;
        $('c-length').disabled = false;
      }
    }
    $('c-mode').addEventListener('change', applyModeLocking);
    applyModeLocking();

    // If user manually sets #speakers to 1, mirror monologue locking UX
    $('c-numSpeakers').addEventListener('change', () => {
      const sp = Number($('c-numSpeakers').value) || 1;
      if (sp === 1) {
        $('c-mode').value = 'monologue';
        applyModeLocking();
      }
    });

    function buildConvoInstruction() {
      const topic = $('c-topic').value.trim();
      const turns = Math.max(1, Number($('c-turns').value) || 10);
      const fib = getSelectedFIB();
      const fibCount = Math.max(20, Math.min(100, turns * 2));
      const L = getLengthPreset();
      const ui = {
        topic,
        level: $('c-level').value,
        sentences_per_turn: { min: L.minSent, max: L.maxSent, minWords: L.minWords, maxWords: L.maxWords },
        vocab: $('c-vocab').value || "(auto-generate level-appropriate list if empty)",
        numConvos: Math.max(1, Number($('c-numConvos').value) || 1),
        numSpeakers: Math.max(1, Number($('c-numSpeakers').value) || 1),
        turns,
        tone: $('c-tone').value,
        region: $('c-country').value,
        fibOptions: fib.active ? fib.tags : [],
        teacherNotes: $('c-notes').value || "",
        mode: $('c-mode').value
      };
      const levelLines = getLevelRulesLines(ui.level);
      const baseRules = [
        `Create EXACTLY ${ui.numConvos} conversation section(s) titled "Conversation 1", "Conversation 2", ...`,
        `Use exactly ${ui.numSpeakers} distinct speaker name(s) appropriate to the region.`,
        `Each conversation has EXACTLY ${ui.turns} turns (rows).`,
        `Tables have two columns: "English" | "Espa√±ol".`,
        `ABSOLUTE LENGTH COMPLIANCE: In EVERY turn, produce between ${ui.sentences_per_turn.min} and ${ui.sentences_per_turn.max} sentences in BOTH columns.`,
        `Each sentence must have between ${ui.sentences_per_turn.minWords} and ${ui.sentences_per_turn.maxWords} words.`,
        `Prefix only the first sentence of each turn in both columns with the speaker name in brackets (do not repeat the name for multiple sentences in the same turn).`,
        ui.mode === 'monologue' ? `This is a monologue: one speaker, one long turn; still obey all length limits.` : `This is a dialogue: distribute turns between speakers.`
      ];
      const fibRules = (!fib.active)
        ? [
            `No Fill-in-the-Blank section.`,
            `INSTEAD, include ONE section after the conversations:`,
            `‚Ä¢ "Common Phrases" ‚Äî full phrases, English | Espa√±ol.`,
            `(Do NOT include "Vocabulary used" / "Full Vocabulary Index".)`
          ]
        : [
            `Include a Fill-in-the-Blank section with about ${fibCount} items.`,
            `FIB focus: ${fib.label}.`,
            `FIB formatting (STRICT):`,
            `‚Ä¢ English column: full sentence; color ONLY the target English word with <span class="en">‚Ä¶</span>.`,
            `‚Ä¢ Spanish column: full sentence with the target Spanish word replaced by "_____" (underscores) and its English translation in parentheses.`,
            `MANDATORY: Numbered Answer Key after FIB ‚Äî full Spanish sentences with the missing word filled in and highlighted with <span class="es">‚Ä¶</span>.`,
            `(Do NOT include any "Vocabulary used" list.)`
          ];
      const footer = [
        `GLOBAL: Stay on topic "${ui.topic}". Self-check all numeric constraints before responding.`
      ];
      return [
        `You are an expert assistant for FCS.`,
        `IMPORTANT: Do NOT return HTML. Produce TWO PARTS (Word + CSV).`,
        `Topic: "${ui.topic}". Level: ${ui.level}. Tone: "${ui.tone}". Region: "${ui.region}". Mode: ${ui.mode}.`,
        ui.vocab && ui.vocab !== "(auto-generate level-appropriate list if empty)"
          ? `Teacher vocabulary (preferred when natural): ${ui.vocab.replace(/[\r\n]+/g, '; ')}`
          : `Vocabulary: auto-generate.`,
        `LEVEL RULES:\n- ${levelLines.join('\n- ')}`,
        '',
        'Rules (strict):', ...baseRules, ...fibRules, '', ...footer
      ].join('\n');
    }

    function buildConvoPrompt() {
      const topic = $('c-topic').value.trim();
      const L = getLengthPreset();
      const fib = getSelectedFIB();
      const turns = Math.max(1, Number($('c-turns').value) || 10);
      const fibCount = Math.max(20, Math.min(100, turns * 2));
      const ui = {
        topic,
        level: $('c-level').value,
        sentences_per_turn: { min: L.minSent, max: L.maxSent, minWords: L.minWords, maxWords: L.maxWords },
        vocab: $('c-vocab').value || "(auto-generate level-appropriate list if empty)",
        numConvos: Math.max(1, Number($('c-numConvos').value) || 1),
        numSpeakers: Math.max(1, Number($('c-numSpeakers').value) || 1),
        turns,
        tone: $('c-tone').value,
        region: $('c-country').value,
        fibOptions: fib.active ? fib.tags : [],
        teacherNotes: $('c-notes').value || "",
        mode: $('c-mode').value
      };
      const levelLines = getLevelRulesLines(ui.level);
      const isMono = (ui.mode === 'monologue');
      const rules = [
        `Create EXACTLY UI.numConvos conversation sections: "Conversation 1"...`,
        `Each conversation has EXACTLY UI.turns turns (rows).`,
        `Use EXACTLY UI.numSpeakers speaker name(s); ${isMono ? 'use the same name for all content (monologue).' : 'alternate turns between speakers.'}`,
        `ABSOLUTE LENGTH COMPLIANCE: Each turn has between UI.sentences_per_turn.min and UI.sentences_per_turn.max sentences in BOTH columns.`,
        `Each sentence has between UI.sentences_per_turn.minWords and UI.sentences_per_turn.maxWords. ${isMono ? 'Prefer the UPPER bound for a very long monologue.' : ''}`,
        `Prefix EVERY sentence‚Äôs first sentence in BOTH columns with the speaker name in brackets, e.g., [Mar√≠a] ...`,
        'Headers must be exactly "English" and "Espa√±ol".',
        `Tone: "${ui.tone}". Region: "${ui.region}". Level: ${ui.level}. Mode: ${ui.mode}.`,
        `LEVEL RULES:\n- ${levelLines.join('\n- ')}`,
        (fib.active ? `Include about ${fibCount} Fill-in-the-Blank items focused on: ${fib.tags.join(', ')}.` : 'Include only "Common Phrases" after conversations.'),
        (fib.active ? `FIB: In English, each sentence has one <span class="en">target</span> word; in Spanish, replace the missing word with "_____" and include its English meaning in parentheses.` : ''),
        (fib.active ? `Also include a numbered Answer Key section with the full Spanish sentences (missing words filled in and highlighted in <span class="es">red</span>). Do NOT include a vocabulary list.` : 'Do NOT include "Vocabulary used" or "Full Vocabulary Index".'),
        'No empty <tbody>. SELF-CHECK all constraints before returning.'
      ].filter(Boolean);
      const safeTopic = safeForScriptTemplate(ui.topic);
      const uiJson = safeForScriptTemplate(JSON.stringify(ui));
      const conversationsHTML = Array.from({ length: ui.numConvos }).map((_, i) => `
  <div class="section">
    <h2>Conversation ${i + 1}</h2>
    <table class="tbl">
      <thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>`).join('');
      const fibLabel = fib.active ? fib.tags.join(', ') : '';
      return `<!DOCTYPE html>
<!-- FCS CONVERSATION OUTPUT -->
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Conversation ‚Äî ${safeTopic}</title>
<style>
  :root{ --ink:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --bg:#ffffff; --en:#1a73e8; --es:#d93025; --h:#0f172a; }
  *{ box-sizing:border-box; }
  body{ font-family:Calibri,Arial,sans-serif; font-size:11pt; line-height:1.4; color:var(--ink); background:var(--bg); margin:0; }
  .fcs-doc{ max-width:980px; margin:0 auto; padding:24px; }
  h1{ font-size:20pt; text-align:center; color:var(--h); margin:0 0 12px 0; }
  h2{ font-size:13pt; color:var(--h); margin:16px 0 8px 0; text-align:center; }
  .section{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px; margin:14px 0; overflow-x:auto; }
  .legend{ font-size:9pt; color:var(--muted); text-align:center; margin-top:6px; }
  .tbl{ width:100%; border-collapse:separate; border-spacing:0; margin-top:10px; }
  .tbl th, .tbl td{ border:1px solid var(--border); padding:8px; vertical-align:top; }
  .tbl th{ background:#f5f7fb; font-weight:700; }
  .tbl tr:nth-child(even) td{ background:#fafafa; }
  .en{ color:var(--en); font-weight:700; }
  .es{ color:var(--es); font-weight:700; }
</style>
</head>
<body>
<div class="fcs-doc">
  <h1>Conversation: ${safeTopic} ‚Äî Level ${ui.level} ‚Äî ${ui.mode === 'monologue' ? 'Monologue' : 'Dialogue'}</h1>
  <div class="legend"><span class="en">EN vocab = blue</span> | <span class="es">ES vocab = red</span>.</div>

  <!-- CONTRACT:
    UI = ${uiJson}
    ${rules.map(r => `- ${r}`).join('\n    ')}
  -->

  ${conversationsHTML}

  ${fib.active ? `
  <div class="section">
    <h2>Practice ‚Äî Fill-in-the-Blank (${fibLabel})</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>
  <div class="section">
    <h2>Answer Key</h2>
    <table class="tbl"><thead><tr><th>#</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>` : `
  <div class="section">
    <h2>Common Phrases</h2>
    <table class="tbl"><thead><tr><th>English</th><th lang="es">Espa√±ol</th></tr></thead><tbody></tbody></table>
  </div>`}

  ${ui.teacherNotes ? `<div class="legend" style="white-space:pre-wrap; margin-top:8px;">Teacher notes:\n${ui.teacherNotes.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>` : ''}

</div>
</body>
</html>`;
    }

    // Validator for Conversation output (updated for FIB blanks + length rules, and no Vocabulary Index)
    function convoValidator(html) {
      try {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const L = getLengthPreset();
        const expectedTurns = Math.max(1, Number($('c-turns').value) || 10);
        const fib = getSelectedFIB();
        const convSections = Array.from(doc.querySelectorAll('h2')).filter(h => /^Conversation\s+\d+/i.test(h.textContent));
        if (!convSections.length) return 'Missing conversation sections.';
        for (const h of convSections) {
          const tbody = h.parentElement.querySelector('table tbody');
          if (!tbody) return `${h.textContent}: table body missing.`;
          const rows = Array.from(tbody.querySelectorAll('tr'));
          if (rows.length !== expectedTurns) return `${h.textContent}: must have exactly ${expectedTurns} turns (rows). Found ${rows.length}.`;
          for (let i = 0; i < rows.length; i++) {
            const tds = rows[i].querySelectorAll('td');
            if (tds.length < 2) return `${h.texttextContent}, row ${i+1}: needs two cells (English | Espa√±ol).`;
            const checkCell = (txt, label) => {
              const clean = txt.replace(/^\s*üîä\s*(EN|ES)\s*/, '').trim();
              const sents = splitIntoSentences(clean);
              if (sents.length < L.minSent || sents.length > L.maxSent) {
                return `${h.textContent}, row ${i+1} (${label}): must have ${L.minSent}‚Äì${L.maxSent} sentences; found ${sents.length}.`;
              }
              for (let k = 0; k < sents.length; k++) {
                const words = sents[k].replace(/[‚Äú‚Äù"()]/g, '').trim().split(/\s+/).filter(Boolean);
                if (words.length < L.minWords || words.length > L.maxWords) {
                  return `${h.textContent}, row ${i+1} (${label}), sentence ${k+1}: has ${words.length} words; needs ${L.minWords}‚Äì${L.maxWords}.`;
                }
              }
              return "";
            };
            const enErr = checkCell(tds[0].innerText, 'English'); if (enErr) return enErr;
            const esErr = checkCell(tds[1].innerText, 'Espa√±ol'); if (esErr) return esErr;
          }
        }
        if (fib.active) {
          const fibH = Array.from(doc.querySelectorAll('h2')).find(h => /Practice ‚Äî Fill-in-the-Blank/i.test(h.textContent));
          if (!fibH) return 'Missing "Practice ‚Äî Fill-in-the-Blank" section.';
          const fibBody = fibH.parentElement.querySelector('table tbody');
          if (!fibBody) return 'FIB table body missing.';
          const rows = Array.from(fibBody.querySelectorAll('tr'));
          for (let i = 0; i < rows.length; i++) {
            const tds = rows[i].querySelectorAll('td');
            if (tds.length < 2) return `FIB row ${i+1}: needs two cells (English | Espa√±ol).`;
            const enHTML = tds[0].innerHTML;
            if (!/<span\s+class="en">[^<]+<\/span>/i.test(enHTML)) {
              return `FIB row ${i+1}: English cell must highlight the target word with <span class="en">‚Ä¶</span>.`;
            }
            const esText = tds[1].innerText;
            const esHTML = tds[1].innerHTML;
            // Must contain blank "_____" and an English gloss in parentheses
            if (!/_{3,}/.test(esHTML)) return `FIB row ${i+1}: Spanish cell must include a blank (_____).`;
            const esSents = splitIntoSentences(esText);
            if (!esSents.length) return `FIB row ${i+1}: Spanish cell must include a sentence.`;
            let hasGloss = false;
            for (let k = 0; k < esSents.length; k++) {
              if (/\([\w\s,'-]+\)/.test(esSents[k])) { hasGloss = true; break; }
            }
            if (!hasGloss) return `FIB row ${i+1}: Spanish must include the English meaning in parentheses.`;
          }
          const ansH = Array.from(doc.querySelectorAll('h2')).find(h => /Answer Key/i.test(h.textContent));
          if (!ansH) return 'Missing "Answer Key" section.';
          const ansBody = ansH.parentElement.querySelector('table tbody');
          if (!ansBody) return 'Answer Key table body missing.';
          const answerRows = Array.from(ansBody.querySelectorAll('tr'));
          for (let j = 0; j < answerRows.length; j++) {
            const cells = answerRows[j].querySelectorAll('td');
            if (cells.length < 2) return `Answer Key row ${j+1} must have two columns (# and Espa√±ol sentence).`;
            const num = cells[0].innerText.trim();
            if (num !== String(j+1)) return `Answer Key row ${j+1} numbering is incorrect (got "${num}").`;
            if (!cells[1].querySelector('span.es')) return `Answer Key row ${j+1}: missing highlighted filled answer word in red.`;
          }
        } else {
          // If no FIB: ensure there is Common Phrases, and there is NO "Vocabulary Index"
          const phrasesH = Array.from(doc.querySelectorAll('h2')).find(h => /Common Phrases/i.test(h.textContent));
          if (!phrasesH) return 'When FIB is none, include "Common Phrases".';
          const anyIndex = Array.from(doc.querySelectorAll('h2')).some(h => /Full Vocabulary Index|Vocabulary used/i.test(h.textContent));
          if (anyIndex) return 'Remove "Vocabulary used" / "Full Vocabulary Index" when FIB is none.';
        }
        return "";
      } catch (e) {
        return "";
      }
    }

    function buildConvoInstructionForPromptButton() {
      // High-fidelity prompt that reproduces our HTML contract in any AI
      const topic = $('c-topic').value.trim();
      const fib = getSelectedFIB();
      const L = getLengthPreset();
      const turns = Math.max(1, Number($('c-turns').value) || 10);
      const fibCount = Math.max(20, Math.min(100, turns * 2));
      const mode = $('c-mode').value;
      const info = [
        `You are an expert assistant for FCS.`,
        `Generate a two-column output (English | Espa√±ol) with one table per conversation section.`,
        `Topic: "${topic}". Level: ${$('c-level').value}. Tone: "${$('c-tone').value}". Region: "${$('c-country').value}". Mode: ${mode}.`,
        `Create EXACTLY ${Math.max(1, Number($('c-numConvos').value) || 1)} conversation section(s) titled "Conversation 1", "Conversation 2", ...`,
        `Use exactly ${Math.max(1, Number($('c-numSpeakers').value) || 1)} speaker name(s) appropriate to the region.`,
        `Each conversation has EXACTLY ${Math.max(1, Number($('c-turns').value) || 10)} turns (rows).`,
        `ABSOLUTE LENGTH COMPLIANCE: Each turn = ${L.minSent}‚Äì${L.maxSent} sentences per column; each sentence = ${L.minWords}‚Äì${L.maxWords} words.`,
        `Prefix only the first sentence of each turn in both columns with the speaker name in brackets (e.g., [Mar√≠a]).`,
        mode === 'monologue' ? `Monologue: 1 conversation, 1 speaker, 1 turn; maximize within the above sentence/word ranges.` : `Dialogue: distribute turns naturally between speakers.`,
        fib.active
          ? [
              `Include a "Practice ‚Äî Fill-in-the-Blank (${fib.tags.join(', ')})" section with about ${fibCount} rows.`,
              `FIB English cell: include one <span class="en">target</span> word.`,
              `FIB Spanish cell: replace the target Spanish word with "_____" and include the English meaning in parentheses.`,
              `Add "Answer Key" with numbered rows; each Spanish sentence must include the filled word highlighted with <span class="es">‚Ä¶</span>.`
            ].join('\n')
          : `After conversations, include ONLY "Common Phrases" (English | Espa√±ol). Do NOT include "Vocabulary used" / "Full Vocabulary Index".`,
        `Follow the level rules exactly:\n- ${getLevelRulesLines($('c-level').value).join('\n- ')}`,
        `Return the output as HTML with a root .fcs-doc element and individual <table> blocks.`
      ].join('\n');
      return info;
    }

    async function callAPI(prompt) {
      const resp = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt })
      });
      const json = await resp.json();
      if (!resp.ok) throw new Error(json.details || json.error || "Unknown server error.");
      return json.content;
    }

    async function generateAndRender(basePrompt, button, statusEl, outputEl, validator, maxRetries = 0) {
      try {
        button.disabled = true;
        statusEl.textContent = "Generating...";
        outputEl.innerHTML = "<h4>Please wait. AI is working...</h4>";
        let html = await callAPI(basePrompt);
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          const err = validator ? validator(html) : "";
          if (!err) break;
          statusEl.textContent = `Fixing constraints‚Ä¶ (${attempt + 1}/${maxRetries})`;
          html = await callAPI(basePrompt + `\n\n<!-- FIX STRICTLY:\n${err}\nABSOLUTE COMPLIANCE: Meet all numeric ranges exactly. -->`);
        }
        renderGenerated(html, outputEl);
        await Speech.ensure();
        addPerLineTTS(outputEl);
        addConversationGlobalTTS(outputEl);
        addGlobalSpanishControls(outputEl); // NEW global Spanish-only bar
        statusEl.textContent = "Done.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Generation failed.";
        outputEl.innerHTML = "<p style='color:#d93025'>An error occurred while generating. Please try again.</p>";
      } finally {
        button.disabled = false;
      }
    }

    function copyToClipboard(container, statusEl) {
      try {
        const txt = container.innerText.trim();
        if (!txt) { statusEl.textContent = "Nothing to copy."; return; }
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(txt).then(() => statusEl.textContent = "Copied!", () => {
            const t = document.createElement("textarea");
            t.value = txt; document.body.appendChild(t); t.select();
            try {
              if (document.execCommand("copy")) statusEl.textContent = "Copied!";
              else statusEl.textContent = "Copy failed.";
            } catch (e) { statusEl.textContent = "Copy failed."; }
            document.body.removeChild(t);
          });
        } else {
          const t = document.createElement("textarea");
          t.value = txt; document.body.appendChild(t); t.select();
          try {
            if (document.execCommand("copy")) statusEl.textContent = "Copied!";
            else statusEl.textContent = "Copy failed.";
          } catch (e) { statusEl.textContent = "Copy failed."; }
          document.body.removeChild(t);
        }
      } catch (e) {
        statusEl.textContent = "Copy failed.";
      }
    }

    function copyText(text, statusEl) {
      const t = (text || "").trim();
      if (!t) { statusEl.textContent = "Nothing to copy."; return; }
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(t).then(() => statusEl.textContent = "Prompt copied!", () => {
          const ta = document.createElement("textarea");
          ta.value = t; document.body.appendChild(ta); ta.select();
          try {
            if (document.execCommand("copy")) statusEl.textContent = "Prompt copied!";
            else statusEl.textContent = "Copy failed.";
          } catch (e) {
            statusEl.textContent = "Copy failed.";
          }
          document.body.removeChild(ta);
        });
      } else {
        const ta = document.createElement("textarea");
        ta.value = t; document.body.appendChild(ta); ta.select();
        try {
          if (document.execCommand("copy")) statusEl.textContent = "Prompt copied!";
          else statusEl.textContent = "Copy failed.";
        } catch (e) {
          statusEl.textContent = "Copy failed.";
        }
        document.body.removeChild(ta);
      }
    }

    function copyContent(mode, container, statusEl) {
      try {
        let text = "";
        if (mode === 'es-only') {
          const lines = [];
          container.querySelectorAll('table').forEach(table => {
            const ths = table.querySelectorAll('th');
            if (ths.length >= 2 && ths[1].textContent.trim().toLowerCase() === 'espa√±ol') {
              table.querySelectorAll('tbody tr').forEach(tr => {
                const cells = tr.querySelectorAll('td');
                if (cells.length >= 2) {
                  const spText = cells[1].innerText.trim();
                  if (spText) lines.push(spText);
                }
              });
            }
          });
          text = lines.join("\n");
        } else {
          text = container.innerText.trim();
        }
        if (!text) { statusEl.textContent = "Nothing to copy."; return; }
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(text).then(() => {
            statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
          }, () => {
            const ta = document.createElement("textarea");
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            try {
              if (document.execCommand("copy")) {
                statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
              } else {
                statusEl.textContent = "Copy failed.";
              }
            } catch (e) {
              statusEl.textContent = "Copy failed.";
            }
            document.body.removeChild(ta);
          });
        } else {
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try {
            if (document.execCommand("copy")) {
              statusEl.textContent = (mode === 'es-only') ? "Spanish content copied!" : "Copied!";
            } else {
              statusEl.textContent = "Copy failed.";
            }
          } catch (e) {
            statusEl.textContent = "Copy failed.";
          }
          document.body.removeChild(ta);
        }
      } catch (err) {
        statusEl.textContent = "Copy failed.";
      }
    }

    function downloadAsExcel(container, statusEl, filename) {
      try {
        const firstTable = container.querySelector("table");
        if (!firstTable) { statusEl.textContent = "No data to export."; return; }
        statusEl.textContent = "Creating Excel...";
        const wb = XLSX.utils.book_new(), rows = [];
        const title = container.querySelector("h1") ? container.querySelector("h1").innerText : (filename || 'Export');
        rows.push([title]); rows.push([]);
        container.querySelectorAll("h2, table").forEach(el => {
          if (el.tagName === "H2") { rows.push([el.innerText]); }
          if (el.tagName === "TABLE") {
            el.querySelectorAll("tr").forEach(tr => {
              const line = Array.from(tr.querySelectorAll("th, td")).map(td => {
                const clone = td.cloneNode(true);
                clone.querySelectorAll('.tts-line-btn').forEach(b => b.remove());
                return clone.innerText;
              });
              rows.push(line);
            });
            rows.push([]);
          }
        });
        const ws = XLSX.utils.aoa_to_sheet(rows);
        ws["!cols"] = rows.reduce((acc, row) => {
          row.forEach((cell, i) => {
            const w = (cell ? cell.toString() : "").length + 2;
            if (!acc[i] || acc[i].wch < w) acc[i] = { wch: w };
          });
          return acc;
        }, []);
        XLSX.utils.book_append_sheet(wb, ws, "Generated Content");
        XLSX.writeFile(wb, `${(filename || 'Export').replace(/\s+/g, "_")}.xlsx`);
        statusEl.textContent = "Download started.";
      } catch (e) {
        console.error("Excel Error:", e);
        statusEl.textContent = "Failed to create Excel.";
      }
    }

    // Events
    $('c-gen').addEventListener('click', async () => {
      const topic = $('c-topic').value.trim();
      if (!topic) { statusEl.textContent = "Enter a topic."; return; }
      await generateAndRender(buildConvoPrompt(), genBtn, statusEl, outputEl, convoValidator, 0);
    });

    $('c-prompt').addEventListener('click', () => {
      const topic = $('c-topic').value.trim();
      if (!topic) { statusEl.textContent = "Enter a topic."; return; }
      copyText(buildConvoInstructionForPromptButton(), statusEl);
    });

    $('c-copy-mode').addEventListener('change', () => {
      const mode = $('c-copy-mode').value;
      if (!mode) return;
      copyContent(mode, outputEl, statusEl);
      $('c-copy-mode').selectedIndex = 0;
    });

    $('c-excel').addEventListener('click', () => downloadAsExcel(outputEl, statusEl, $('c-topic').value || 'Conversation'));
  })();

  /* =========================
     Test Generator (unchanged)
     ========================= */
  (function setupTest() {
    const testUI = 
      `<div class="fcs-card">
        <h2>Test Creator</h2>
        <div><label for="t-vocab">Vocabulary List</label><textarea id="t-vocab" rows="6" placeholder="Paste the EXACT vocabulary for the test..."></textarea></div>
        <div><label for="t-level">Level (Grammar)</label>
          <select id="t-level">
            <option value="1" selected>Level 1 ‚Äî Survival</option>
            <option value="2">Level 2 ‚Äî Beginner</option>
            <option value="3">Level 3 ‚Äî Intermediate</option>
            <option value="4">Level 4 ‚Äî Conversational</option>
            <option value="5">Level 5 ‚Äî Fluent</option>
          </select>
        </div>
        <div><label><input type="checkbox" id="t-anskeys" checked> Include Teacher Answer Keys?</label></div>
        <div class="actions">
          <button id="t-gen" class="primary">Generate</button>
          <button id="t-excel">Excel</button>
          <button id="t-copy">Copy</button>
          <div id="t-status" class="status"></div>
        </div>
      </div>
      <div id="t-output" class="output-container"><p>Your test will appear here...</p></div>`;
    $('gen-test').innerHTML = testUI;

    const genBtn = $('t-gen'),
          excelBtn = $('t-excel'),
          copyBtn = $('t-copy'),
          statusEl = $('t-status'),
          outputEl = $('t-output');

    async function callAPI(prompt) {
      const resp = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt })
      });
      const json = await resp.json();
      if (!resp.ok) throw new Error(json.details || json.error || "Unknown server error.");
      return json.content;
    }

    function downloadAsExcel(container, statusEl, filename) {
      try {
        const firstTable = container.querySelector("table");
        if (!firstTable) { statusEl.textContent = "No data to export."; return; }
        statusEl.textContent = "Creating Excel...";
        const wb = XLSX.utils.book_new(), rows = [];
        const title = container.querySelector("h1") ? container.querySelector("h1").innerText : (filename || 'Export');
        rows.push([title]); rows.push([]);
        container.querySelectorAll("h2, table").forEach(el => {
          if (el.tagName === "H2") { rows.push([el.innerText]); }
          if (el.tagName === "TABLE") {
            el.querySelectorAll("tr").forEach(tr => {
              const line = Array.from(tr.querySelectorAll("th, td")).map(td => {
                const clone = td.cloneNode(true);
                clone.querySelectorAll('.tts-line-btn').forEach(b => b.remove());
                return clone.innerText;
              });
              rows.push(line);
            });
            rows.push([]);
          }
        });
        const ws = XLSX.utils.aoa_to_sheet(rows);
        ws["!cols"] = rows.reduce((acc, row) => {
          row.forEach((cell, i) => {
            const w = (cell ? cell.toString() : "").length + 2;
            if (!acc[i] || acc[i].wch < w) acc[i] = { wch: w };
          });
          return acc;
        }, []);
        XLSX.utils.book_append_sheet(wb, ws, "Generated Content");
        XLSX.writeFile(wb, `${(filename || 'Export').replace(/\s+/g, "_")}.xlsx`);
        statusEl.textContent = "Download started.";
      } catch (e) {
        console.error("Excel Error:", e);
        statusEl.textContent = "Failed to create Excel.";
      }
    }

    $('t-gen').addEventListener('click', async () => {
      const v = $('t-vocab').value.trim();
      if (!v) { statusEl.textContent = "Please paste a vocab list."; return; }
      const prompt = `<!DOCTYPE html>
<!-- FCS TEST OUTPUT -->
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Test ‚Äî Level ${$('t-level').value}</title>
<style>
  :root{ --ink:#111; --muted:#667085; --border:#e5e7eb; --panel:#ffffff; --bg:#ffffff; --en:#1a73e8; --es:#d93025; --h:#0f172a; }
  *{ box-sizing:border-box; } body{ font-family:Calibri,Arial,sans-serif; font-size:10pt; line-height:1.4; color:var(--ink); background:var(--bg); margin:0; }
  .fcs-doc{ max-width:980px; margin:0 auto; padding:24px; }
  h1{ font-size:20pt; text-align:center; color:var(--h); margin:0 0 12px 0; }
  h2{ font-size:13pt; color:var(--h); margin:16px 0 8px 0; text-align:center; }
  .section{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px; margin-top:14px; overflow-x:auto; }
  .tbl{ width:100%; border-collapse:separate; border-spacing:0; margin-top:10px; }
  .tbl th, .tbl td{ border:1px solid var(--border); padding:8px; vertical-align:top; }
  .tbl th{ background:#f5f7fb; font-weight:700; }
  .tbl tr:nth-child(even) td{ background:#fafafa; }
  .en{ color:var(--en); font-weight:700; } .es{ color:var(--es); font-weight:700; }
  .note{ font-size:9pt; color:var(--muted); }
</style></head>
<body><div class="fcs-doc">
  <h1>FCS Conversation Test ‚Äî Level ${$('t-level').value}</h1>
  <div class="note"><span class="en">English terms = blue</span>; <span class="es">Spanish terms = red</span> whenever vocabulary appears inline.</div>

  <div class="section">
    <h2>Part 1 ‚Äî Spanish ‚Üí English</h2>
    <table class="tbl"><thead><tr><th>#</th><th lang="es">Espa√±ol</th>${$('t-anskeys').checked ? '<th>Answer (EN)</th>' : ''}</tr></thead>
      <tbody><!-- rows --></tbody>
    </table>
  </div>

  <div class="section">
    <h2>Part 2 ‚Äî English ‚Üí Spanish</h2>
    <table class="tbl"><thead><tr><th>#</th><th>English</th>${$('t-anskeys').checked ? '<th lang="es">Answer (ES)</th>' : ''}</tr></thead>
      <tbody><!-- rows --></tbody>
    </table>
  </div>

  <div class="section">
    <h2>Part 3 ‚Äî Live Conversation Prompts</h2>
    <table class="tbl"><thead><tr><th>#</th><th lang="es">Prompt (Espa√±ol)</th></tr></thead>
      <tbody><!-- rows --></tbody>
    </table>
  </div>

  ${$('t-anskeys').checked ? `<div class="section"><h2>Answer Key</h2><!-- answers only --></div>` : ''}

  <div class="note">Vocabulary pasted by teacher:</div>
  <div class="note" style="white-space:pre-wrap; border:1px dashed var(--border); padding:8px; border-radius:8px;">${v.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>
</div></body></html>`;
      try {
        statusEl.textContent = "Generating...";
        const html = await callAPI(prompt);
        renderGenerated(html, outputEl);
        statusEl.textContent = "Done.";
      } catch (e) {
        console.error(e);
        statusEl.textContent = "Generation failed.";
      }
    });

    $('t-copy').addEventListener('click', () => {
      const out = $('t-output');
      const txt = out.innerText.trim();
      if (!txt) { $('t-status').textContent = "Nothing to copy."; return; }
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(txt).then(() => $('t-status').textContent = "Copied!");
      } else {
        const t = document.createElement('textarea');
        t.value = txt; document.body.appendChild(t); t.select();
        try { document.execCommand('copy'); $('t-status').textContent = "Copied!"; }
        catch { $('t-status').textContent = "Copy failed."; }
        document.body.removeChild(t);
      }
    });

    $('t-excel').addEventListener('click', () => {
      const out = $('t-output');
      const status = $('t-status');
      try {
        const firstTable = out.querySelector("table");
        if (!firstTable) { status.textContent = "No data to export."; return; }
        status.textContent = "Creating Excel...";
        const wb = XLSX.utils.book_new(), rows = [];
        const title = out.querySelector("h1") ? out.querySelector("h1").innerText : 'Test';
        rows.push([title]); rows.push([]);
        out.querySelectorAll("h2, table").forEach(el => {
          if (el.tagName === "H2") { rows.push([el.innerText]); }
          if (el.tagName === "TABLE") {
            el.querySelectorAll("tr").forEach(tr => {
              const line = Array.from(tr.querySelectorAll("th, td")).map(td => {
                const clone = td.cloneNode(true);
                clone.querySelectorAll('.tts-line-btn').forEach(b => b.remove());
                return clone.innerText;
              });
              rows.push(line);
            });
            rows.push([]);
          }
        });
        const ws = XLSX.utils.aoa_to_sheet(rows);
        XLSX.utils.book_append_sheet(wb, ws, "Generated Content");
        XLSX.writeFile(wb, `Test.xlsx`);
        status.textContent = "Download started.";
      } catch (e) {
        console.error(e); status.textContent = "Failed to create Excel.";
      }
    });
  })();
})();
</script>
</body>
</html>
